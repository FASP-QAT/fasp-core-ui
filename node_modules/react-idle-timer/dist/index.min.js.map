{"version":3,"file":"index.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\n\n/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nconst IS_BROWSER = (typeof window === 'undefined' ? 'undefined' : typeof (window)) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nconst DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nconst DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mouseWheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove',\n  'visibilitychange'\n]\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nexport default class IdleTimer extends Component {\n  /**\n   * Type checks for every property\n   * @type {Object}\n   * @private\n   */\n  static propTypes = {\n    /**\n     * Activity Timeout in milliseconds\n     * default: 1200000\n     * @type {Number}\n     */\n    timeout: PropTypes.number,\n    /**\n     * DOM events to listen to\n     * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n     * @type {Array}\n     */\n    events: PropTypes.arrayOf(PropTypes.string),\n    /**\n     * Function to call when user is idle\n     * default: () => {}\n     * @type {Function}\n     */\n    onIdle: PropTypes.func,\n    /**\n     * Function to call when user becomes active\n     * default: () => {}\n     * @type {Function}\n     */\n    onActive: PropTypes.func,\n    /**\n     * Function to call on user actions\n     * default: () => {}\n     * @type {Function}\n     */\n    onAction: PropTypes.func,\n    /**\n     * Debounce the onAction function by setting delay in milliseconds\n     * default: 0\n     * @type {Number}\n     */\n    debounce: PropTypes.number,\n    /**\n     * Throttle the onAction function by setting delay in milliseconds\n     * default: 0\n     * @type {Number}\n     */\n    throttle: PropTypes.number,\n    /**\n     * Element reference to bind activity listeners to\n     * default: document\n     * @type {Object}\n     */\n    element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n    /**\n     * Start the timer on mount\n     * default: true\n     * @type {Boolean}\n     */\n    startOnMount: PropTypes.bool,\n    /**\n     * Once the user goes idle the IdleTimer will not\n     * reset on user input instead, reset() must be\n     * called manually to restart the timer\n     * default: false\n     * @type {Boolean}\n     */\n    stopOnIdle: PropTypes.bool,\n    /**\n     * Bind events passively\n     * default: true\n     * @type {Boolean}\n     */\n    passive: PropTypes.bool,\n    /**\n     * Capture events\n     * default: true\n     * @type {Boolean}\n     */\n    capture: PropTypes.bool\n  }\n\n  /**\n   * Sets default property values\n   * @type {Object}\n   * @private\n   */\n  static defaultProps = {\n    timeout: 1000 * 60 * 20,\n    element: DEFAULT_ELEMENT,\n    events: DEFAULT_EVENTS,\n    onIdle: () => {},\n    onActive: () => {},\n    onAction: () => {},\n    debounce: 0,\n    throttle: 0,\n    startOnMount: true,\n    stopOnIdle: false,\n    capture: true,\n    passive: true\n  }\n\n  /**\n   * Sets initial component state\n   * @type {Object}\n   * @private\n   */\n  state = {\n    idle: false,\n    oldDate: +new Date(),\n    lastActive: +new Date(),\n    remaining: null,\n    pageX: null,\n    pageY: null\n  }\n\n  /**\n   * The timer instance\n   * @type {Timeout}\n   * @private\n   */\n  tId = null\n\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n\n    // Debounce and throttle cant both be set\n    if (props.debounce > 0 && props.throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create debounced action if applicable\n    if (props.debounce > 0) {\n      this.debouncedAction = debounced(props.onAction, props.debounce)\n    }\n\n    // Create throttled action if applicable\n    if (props.throttle > 0) {\n      this.throttledAction = throttled(props.onAction, props.throttle)\n    }\n\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount) {\n      this.state.idle = true\n    }\n\n    // Bind all events to component scope, built for speed ðŸš€\n    this.toggleIdleState = this._toggleIdleState.bind(this)\n    this.reset = this.reset.bind(this)\n    this.pause = this.pause.bind(this)\n    this.resume = this.resume.bind(this)\n    this.getRemainingTime = this.getRemainingTime.bind(this)\n    this.getElapsedTime = this.getElapsedTime.bind(this)\n    this.getLastActiveTime = this.getLastActiveTime.bind(this)\n    this.isIdle = this._isIdle.bind(this)\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    // Bind the event listeners\n    this._bindEvents()\n    // If startOnMount is enabled start the timer\n    const { startOnMount } = this.props\n    if (startOnMount) {\n      this.reset()\n    }\n  }\n\n  componentDidUpdate (prevProps) {\n    // Update debounce function\n    if (prevProps.debounce !== this.props.debounce) {\n      this.debouncedAction = debounced(this.props.onAction, this.props.debounce)\n    }\n    // Update throttle function\n    if (prevProps.throttle !== this.props.throttle) {\n      this.throttledAction = throttled(this.props.onAction, this.props.throttle)\n    }\n  }\n\n  /**\n   * Called before the component unmounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    clearTimeout(this.tId)\n    this._unbindEvents(true)\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  _bindEvents () {\n    // Dont bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { eventsBound } = this.state\n    const { element, events, passive, capture } = this.props\n    if (!eventsBound) {\n      events.forEach(e => {\n        element.addEventListener(e, this._handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.setState({ eventsBound: true })\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  _unbindEvents (force = false) {\n    // If we are not in a browser\n    // we dont need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    const { eventsBound } = this.state\n    if (eventsBound || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, this._handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.setState({ eventsBound: false })\n    }\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Fire the appropriate action\n    // and pass the event through\n    // Toggle the idle state\n    this.setState((prevState) => ({\n      idle: !prevState.idle\n    }), () => {\n      const { onActive, onIdle, stopOnIdle } = this.props\n      const { idle } = this.state\n      if (!idle) {\n        if (!stopOnIdle) {\n          this._bindEvents()\n          onActive(e)\n        }\n      } else {\n        if (stopOnIdle) {\n          // Clear any existing timeout\n          clearTimeout(this.tId)\n          this.tId = null\n          // Unbind events\n          this._unbindEvents()\n        }\n        onIdle(e)\n      }\n    })\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent = (e) => {\n    const { remaining, pageX, pageY, idle } = this.state\n    const { timeout, onAction, debounce, throttle, stopOnIdle } = this.props\n\n    // Fire debounced, throttled or raw onAction callback with event\n    if (debounce > 0) {\n      this.debouncedAction(e)\n    } else if (throttle > 0) {\n      this.throttledAction(e)\n    } else {\n      onAction(e)\n    }\n\n    // Already active, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coord are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coord don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      //\n      // TODO: Cant seem to simulate this event with pageX and pageY for testing\n      // making this block of code unreachable by test suite\n      // opened an issue here https://github.com/Rich-Harris/simulant/issues/19\n      const elapsed = this.getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = new Date() - this.getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if ((idle && !stopOnIdle) || (!idle && elapsedTimeSinceLastActive > timeout)) {\n      this.toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(), // store when user was last active\n      pageX: e.pageX, // update mouse coord\n      pageY: e.pageY\n    })\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle) {\n      if (!stopOnIdle) {\n        this.tId = setTimeout(this.toggleIdleState, timeout)\n      }\n    } else {\n      this.tId = setTimeout(this.toggleIdleState, timeout)\n    }\n  }\n\n  /**\n   * Restore initial state and restart timer\n   * @name reset\n   */\n  reset () {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this.toggleIdleState, timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  pause () {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) {\n      return\n    }\n\n    // Unbind events\n    this._unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  resume () {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) {\n      return\n    }\n\n    // Bind events\n    this._bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle) {\n      this.setState({ remaining: null, lastActive: +new Date() })\n      // Set a new timeout\n      this.tId = setTimeout(this.toggleIdleState, remaining)\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {Number} Milliseconds remaining\n   */\n  getRemainingTime () {\n    const { remaining, lastActive } = this.state\n    const { timeout } = this.props\n\n    // If idle there is no time remaining\n    if (remaining !== null) {\n      return remaining < 0 ? 0 : remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    let timeLeft = timeout - ((+new Date()) - lastActive)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  _isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n}\n\n/**\n * Creates a debounced function that delays invoking func until\n * after delay milliseconds has elapsed since the last time the\n * debounced function was invoked.\n * @name debounced\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n**/\nfunction debounced (fn, delay) {\n  let timerId\n  return function (...args) {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n    timerId = setTimeout(() => {\n      fn(...args)\n      timerId = null\n    }, delay)\n  }\n}\n\n/**\n * Creates a throttled function that only invokes func at most\n * once per every wait milliseconds.\n * @name throttled\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n**/\nfunction throttled (fn, delay) {\n  let lastCall = 0\n  return function (...args) {\n    const now = new Date().getTime()\n    if (now - lastCall < delay) {\n      return\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n"],"names":["debounced","fn","delay","timerId","args","clearTimeout","setTimeout","throttled","lastCall","now","Date","getTime","IS_BROWSER","window","DEFAULT_ELEMENT","document","DEFAULT_EVENTS","IdleTimer","props","idle","oldDate","lastActive","remaining","pageX","pageY","e","_this","state","timeout","onAction","debounce","throttle","stopOnIdle","debouncedAction","throttledAction","type","getElapsedTime","tId","elapsedTimeSinceLastActive","getLastActiveTime","toggleIdleState","setState","Error","startOnMount","_toggleIdleState","bind","reset","pause","resume","getRemainingTime","isIdle","_isIdle","_bindEvents","this","prevProps","_unbindEvents","children","eventsBound","element","events","passive","capture","forEach","addEventListener","_this2","_handleEvent","force","removeEventListener","_this3","prevState","_this4","onActive","onIdle","timeLeft","Component","PropTypes","number","arrayOf","string","func","oneOfType","object","bool"],"mappings":"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"}