{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.sortBreakpoints = sortBreakpoints;\n\nvar _utils = require(\"./utils\");\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\n\n\nfunction getBreakpointFromWidth(breakpoints, width) {\n  var sorted = sortBreakpoints(breakpoints);\n  var matching = sorted[0];\n\n  for (var i = 1, len = sorted.length; i < len; i++) {\n    var breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n\n  return matching;\n}\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\n\n\nfunction getColsFromBreakpoint(breakpoint, cols) {\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n\n  return cols[breakpoint];\n}\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\n\n\nfunction findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactType) {\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]); // Find or generate the next layout\n\n  var layout = layouts[lastBreakpoint];\n  var breakpointsSorted = sortBreakpoints(breakpoints);\n  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n\n  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {\n    var b = breakpointsAbove[i];\n\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\n\n\nfunction sortBreakpoints(breakpoints) {\n  var keys = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}","map":{"version":3,"sources":["/home/altius/Documents/FASP/fasp-core-ui/node_modules/react-grid-layout/build/responsiveUtils.js"],"names":["exports","__esModule","getBreakpointFromWidth","getColsFromBreakpoint","findOrGenerateResponsiveLayout","sortBreakpoints","_utils","require","breakpoints","width","sorted","matching","i","len","length","breakpointName","breakpoint","cols","Error","layouts","lastBreakpoint","compactType","cloneLayout","layout","breakpointsSorted","breakpointsAbove","slice","indexOf","b","compact","correctBounds","keys","Object","sort","a"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.sortBreakpoints = sortBreakpoints;\n\nvar _utils = require(\"./utils\");\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints, width) {\n  var sorted = sortBreakpoints(breakpoints);\n  var matching = sorted[0];\n  for (var i = 1, len = sorted.length; i < len; i++) {\n    var breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\n\n\nfunction getColsFromBreakpoint(breakpoint, cols) {\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nfunction findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactType) {\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);\n  // Find or generate the next layout\n  var layout = layouts[lastBreakpoint];\n  var breakpointsSorted = sortBreakpoints(breakpoints);\n  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {\n    var b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, { cols: cols }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints) {\n  var keys = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}"]},"metadata":{},"sourceType":"script"}