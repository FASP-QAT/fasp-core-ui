{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var htmlConfig = {\n    autoSelfClosers: {\n      'area': true,\n      'base': true,\n      'br': true,\n      'col': true,\n      'command': true,\n      'embed': true,\n      'frame': true,\n      'hr': true,\n      'img': true,\n      'input': true,\n      'keygen': true,\n      'link': true,\n      'meta': true,\n      'param': true,\n      'source': true,\n      'track': true,\n      'wbr': true,\n      'menuitem': true\n    },\n    implicitlyClosed: {\n      'dd': true,\n      'li': true,\n      'optgroup': true,\n      'option': true,\n      'p': true,\n      'rp': true,\n      'rt': true,\n      'tbody': true,\n      'td': true,\n      'tfoot': true,\n      'th': true,\n      'tr': true\n    },\n    contextGrabbers: {\n      'dd': {\n        'dd': true,\n        'dt': true\n      },\n      'dt': {\n        'dd': true,\n        'dt': true\n      },\n      'li': {\n        'li': true\n      },\n      'option': {\n        'option': true,\n        'optgroup': true\n      },\n      'optgroup': {\n        'optgroup': true\n      },\n      'p': {\n        'address': true,\n        'article': true,\n        'aside': true,\n        'blockquote': true,\n        'dir': true,\n        'div': true,\n        'dl': true,\n        'fieldset': true,\n        'footer': true,\n        'form': true,\n        'h1': true,\n        'h2': true,\n        'h3': true,\n        'h4': true,\n        'h5': true,\n        'h6': true,\n        'header': true,\n        'hgroup': true,\n        'hr': true,\n        'menu': true,\n        'nav': true,\n        'ol': true,\n        'p': true,\n        'pre': true,\n        'section': true,\n        'table': true,\n        'ul': true\n      },\n      'rp': {\n        'rp': true,\n        'rt': true\n      },\n      'rt': {\n        'rp': true,\n        'rt': true\n      },\n      'tbody': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'td': {\n        'td': true,\n        'th': true\n      },\n      'tfoot': {\n        'tbody': true\n      },\n      'th': {\n        'td': true,\n        'th': true\n      },\n      'thead': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'tr': {\n        'tr': true\n      }\n    },\n    doNotIndent: {\n      \"pre\": true\n    },\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  };\n  var xmlConfig = {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    allowMissingTagName: false,\n    caseFold: false\n  };\n  CodeMirror.defineMode(\"xml\", function (editorConf, config_) {\n    var indentUnit = editorConf.indentUnit;\n    var config = {};\n    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;\n\n    for (var prop in defaults) {\n      config[prop] = defaults[prop];\n    }\n\n    for (var prop in config_) {\n      config[prop] = config_[prop];\n    } // Return variables for tokenizers\n\n\n    var type, setStyle;\n\n    function inText(stream, state) {\n      function chain(parser) {\n        state.tokenize = parser;\n        return parser(stream, state);\n      }\n\n      var ch = stream.next();\n\n      if (ch == \"<\") {\n        if (stream.eat(\"!\")) {\n          if (stream.eat(\"[\")) {\n            if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));else return null;\n          } else if (stream.match(\"--\")) {\n            return chain(inBlock(\"comment\", \"-->\"));\n          } else if (stream.match(\"DOCTYPE\", true, true)) {\n            stream.eatWhile(/[\\w\\._\\-]/);\n            return chain(doctype(1));\n          } else {\n            return null;\n          }\n        } else if (stream.eat(\"?\")) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          state.tokenize = inBlock(\"meta\", \"?>\");\n          return \"meta\";\n        } else {\n          type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n          state.tokenize = inTag;\n          return \"tag bracket\";\n        }\n      } else if (ch == \"&\") {\n        var ok;\n\n        if (stream.eat(\"#\")) {\n          if (stream.eat(\"x\")) {\n            ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n          } else {\n            ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n          }\n        } else {\n          ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n        }\n\n        return ok ? \"atom\" : \"error\";\n      } else {\n        stream.eatWhile(/[^&<]/);\n        return null;\n      }\n    }\n\n    inText.isInText = true;\n\n    function inTag(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \">\" || ch == \"/\" && stream.eat(\">\")) {\n        state.tokenize = inText;\n        type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n        return \"tag bracket\";\n      } else if (ch == \"=\") {\n        type = \"equals\";\n        return null;\n      } else if (ch == \"<\") {\n        state.tokenize = inText;\n        state.state = baseState;\n        state.tagName = state.tagStart = null;\n        var next = state.tokenize(stream, state);\n        return next ? next + \" tag error\" : \"tag error\";\n      } else if (/[\\'\\\"]/.test(ch)) {\n        state.tokenize = inAttribute(ch);\n        state.stringStartCol = stream.column();\n        return state.tokenize(stream, state);\n      } else {\n        stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n        return \"word\";\n      }\n    }\n\n    function inAttribute(quote) {\n      var closure = function closure(stream, state) {\n        while (!stream.eol()) {\n          if (stream.next() == quote) {\n            state.tokenize = inTag;\n            break;\n          }\n        }\n\n        return \"string\";\n      };\n\n      closure.isInAttribute = true;\n      return closure;\n    }\n\n    function inBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = inText;\n            break;\n          }\n\n          stream.next();\n        }\n\n        return style;\n      };\n    }\n\n    function doctype(depth) {\n      return function (stream, state) {\n        var ch;\n\n        while ((ch = stream.next()) != null) {\n          if (ch == \"<\") {\n            state.tokenize = doctype(depth + 1);\n            return state.tokenize(stream, state);\n          } else if (ch == \">\") {\n            if (depth == 1) {\n              state.tokenize = inText;\n              break;\n            } else {\n              state.tokenize = doctype(depth - 1);\n              return state.tokenize(stream, state);\n            }\n          }\n        }\n\n        return \"meta\";\n      };\n    }\n\n    function Context(state, tagName, startOfLine) {\n      this.prev = state.context;\n      this.tagName = tagName;\n      this.indent = state.indented;\n      this.startOfLine = startOfLine;\n      if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;\n    }\n\n    function popContext(state) {\n      if (state.context) state.context = state.context.prev;\n    }\n\n    function maybePopContext(state, nextTagName) {\n      var parentTagName;\n\n      while (true) {\n        if (!state.context) {\n          return;\n        }\n\n        parentTagName = state.context.tagName;\n\n        if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n          return;\n        }\n\n        popContext(state);\n      }\n    }\n\n    function baseState(type, stream, state) {\n      if (type == \"openTag\") {\n        state.tagStart = stream.column();\n        return tagNameState;\n      } else if (type == \"closeTag\") {\n        return closeTagNameState;\n      } else {\n        return baseState;\n      }\n    }\n\n    function tagNameState(type, stream, state) {\n      if (type == \"word\") {\n        state.tagName = stream.current();\n        setStyle = \"tag\";\n        return attrState;\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return attrState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return tagNameState;\n      }\n    }\n\n    function closeTagNameState(type, stream, state) {\n      if (type == \"word\") {\n        var tagName = stream.current();\n        if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);\n\n        if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n          setStyle = \"tag\";\n          return closeState;\n        } else {\n          setStyle = \"tag error\";\n          return closeStateErr;\n        }\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return closeState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return closeStateErr;\n      }\n    }\n\n    function closeState(type, _stream, state) {\n      if (type != \"endTag\") {\n        setStyle = \"error\";\n        return closeState;\n      }\n\n      popContext(state);\n      return baseState;\n    }\n\n    function closeStateErr(type, stream, state) {\n      setStyle = \"error\";\n      return closeState(type, stream, state);\n    }\n\n    function attrState(type, _stream, state) {\n      if (type == \"word\") {\n        setStyle = \"attribute\";\n        return attrEqState;\n      } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n        var tagName = state.tagName,\n            tagStart = state.tagStart;\n        state.tagName = state.tagStart = null;\n\n        if (type == \"selfcloseTag\" || config.autoSelfClosers.hasOwnProperty(tagName)) {\n          maybePopContext(state, tagName);\n        } else {\n          maybePopContext(state, tagName);\n          state.context = new Context(state, tagName, tagStart == state.indented);\n        }\n\n        return baseState;\n      }\n\n      setStyle = \"error\";\n      return attrState;\n    }\n\n    function attrEqState(type, stream, state) {\n      if (type == \"equals\") return attrValueState;\n      if (!config.allowMissing) setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n\n    function attrValueState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n\n      if (type == \"word\" && config.allowUnquoted) {\n        setStyle = \"string\";\n        return attrState;\n      }\n\n      setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n\n    function attrContinuedState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      return attrState(type, stream, state);\n    }\n\n    return {\n      startState: function startState(baseIndent) {\n        var state = {\n          tokenize: inText,\n          state: baseState,\n          indented: baseIndent || 0,\n          tagName: null,\n          tagStart: null,\n          context: null\n        };\n        if (baseIndent != null) state.baseIndent = baseIndent;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (!state.tagName && stream.sol()) state.indented = stream.indentation();\n        if (stream.eatSpace()) return null;\n        type = null;\n        var style = state.tokenize(stream, state);\n\n        if ((style || type) && style != \"comment\") {\n          setStyle = null;\n          state.state = state.state(type || style, stream, state);\n          if (setStyle) style = setStyle == \"error\" ? style + \" error\" : setStyle;\n        }\n\n        return style;\n      },\n      indent: function indent(state, textAfter, fullLine) {\n        var context = state.context; // Indent multi-line strings (e.g. css).\n\n        if (state.tokenize.isInAttribute) {\n          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;\n        }\n\n        if (context && context.noIndent) return CodeMirror.Pass;\n        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0; // Indent the starts of attribute names.\n\n        if (state.tagName) {\n          if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n        }\n\n        if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n        var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n\n        if (tagAfter && tagAfter[1]) {\n          // Closing tag spotted\n          while (context) {\n            if (context.tagName == tagAfter[2]) {\n              context = context.prev;\n              break;\n            } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n              context = context.prev;\n            } else {\n              break;\n            }\n          }\n        } else if (tagAfter) {\n          // Opening tag spotted\n          while (context) {\n            var grabbers = config.contextGrabbers[context.tagName];\n            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;\n          }\n        }\n\n        while (context && context.prev && !context.startOfLine) {\n          context = context.prev;\n        }\n\n        if (context) return context.indent + indentUnit;else return state.baseIndent || 0;\n      },\n      electricInput: /<\\/[\\s\\w:]+>$/,\n      blockCommentStart: \"<!--\",\n      blockCommentEnd: \"-->\",\n      configuration: config.htmlMode ? \"html\" : \"xml\",\n      helperType: config.htmlMode ? \"html\" : \"xml\",\n      skipAttribute: function skipAttribute(state) {\n        if (state.state == attrValueState) state.state = attrState;\n      },\n      xmlCurrentTag: function xmlCurrentTag(state) {\n        return state.tagName ? {\n          name: state.tagName,\n          close: state.type == \"closeTag\"\n        } : null;\n      },\n      xmlCurrentContext: function xmlCurrentContext(state) {\n        var context = [];\n\n        for (var cx = state.context; cx; cx = cx.prev) {\n          if (cx.tagName) context.push(cx.tagName);\n        }\n\n        return context.reverse();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/xml\", \"xml\");\n  CodeMirror.defineMIME(\"application/xml\", \"xml\");\n  if (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\")) CodeMirror.defineMIME(\"text/html\", {\n    name: \"xml\",\n    htmlMode: true\n  });\n});","map":{"version":3,"sources":["/home/altius/NodeJs/gitHubRepos/fasp-core-ui/node_modules/codemirror/mode/xml/xml.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","htmlConfig","autoSelfClosers","implicitlyClosed","contextGrabbers","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","allowMissingTagName","defineMode","editorConf","config_","indentUnit","config","defaults","htmlMode","prop","type","setStyle","inText","stream","state","chain","parser","tokenize","ch","next","eat","match","inBlock","eatWhile","doctype","inTag","ok","isInText","baseState","tagName","tagStart","test","inAttribute","stringStartCol","column","quote","closure","eol","isInAttribute","style","terminator","depth","Context","startOfLine","prev","context","indent","indented","hasOwnProperty","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","current","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","startState","baseIndent","token","sol","indentation","eatSpace","textAfter","fullLine","Pass","length","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","exec","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","xmlCurrentTag","name","close","xmlCurrentContext","cx","push","reverse","defineMIME","mimeModes"],"mappings":"AAAA;AACA;AAEA,CAAC,UAASA,GAAT,EAAc;AACb,MAAI,OAAOC,OAAP,IAAkB,QAAlB,IAA8B,OAAOC,MAAP,IAAiB,QAAnD,EAA6D;AAC3DF,IAAAA,GAAG,CAACG,OAAO,CAAC,sBAAD,CAAR,CAAH,CADF,KAEK,IAAI,OAAOC,MAAP,IAAiB,UAAjB,IAA+BA,MAAM,CAACC,GAA1C,EAA+C;AAClDD,IAAAA,MAAM,CAAC,CAAC,sBAAD,CAAD,EAA2BJ,GAA3B,CAAN,CADG,KAEA;AACHA,IAAAA,GAAG,CAACM,UAAD,CAAH;AACH,CAPD,EAOG,UAASA,UAAT,EAAqB;AACxB;;AAEA,MAAIC,UAAU,GAAG;AACfC,IAAAA,eAAe,EAAE;AAAC,cAAQ,IAAT;AAAe,cAAQ,IAAvB;AAA6B,YAAM,IAAnC;AAAyC,aAAO,IAAhD;AAAsD,iBAAW,IAAjE;AACC,eAAS,IADV;AACgB,eAAS,IADzB;AAC+B,YAAM,IADrC;AAC2C,aAAO,IADlD;AACwD,eAAS,IADjE;AAEC,gBAAU,IAFX;AAEiB,cAAQ,IAFzB;AAE+B,cAAQ,IAFvC;AAE6C,eAAS,IAFtD;AAE4D,gBAAU,IAFtE;AAGC,eAAS,IAHV;AAGgB,aAAO,IAHvB;AAG6B,kBAAY;AAHzC,KADF;AAKfC,IAAAA,gBAAgB,EAAE;AAAC,YAAM,IAAP;AAAa,YAAM,IAAnB;AAAyB,kBAAY,IAArC;AAA2C,gBAAU,IAArD;AAA2D,WAAK,IAAhE;AACC,YAAM,IADP;AACa,YAAM,IADnB;AACyB,eAAS,IADlC;AACwC,YAAM,IAD9C;AACoD,eAAS,IAD7D;AAEC,YAAM,IAFP;AAEa,YAAM;AAFnB,KALH;AAQfC,IAAAA,eAAe,EAAE;AACf,YAAM;AAAC,cAAM,IAAP;AAAa,cAAM;AAAnB,OADS;AAEf,YAAM;AAAC,cAAM,IAAP;AAAa,cAAM;AAAnB,OAFS;AAGf,YAAM;AAAC,cAAM;AAAP,OAHS;AAIf,gBAAU;AAAC,kBAAU,IAAX;AAAiB,oBAAY;AAA7B,OAJK;AAKf,kBAAY;AAAC,oBAAY;AAAb,OALG;AAMf,WAAK;AAAC,mBAAW,IAAZ;AAAkB,mBAAW,IAA7B;AAAmC,iBAAS,IAA5C;AAAkD,sBAAc,IAAhE;AAAsE,eAAO,IAA7E;AACC,eAAO,IADR;AACc,cAAM,IADpB;AAC0B,oBAAY,IADtC;AAC4C,kBAAU,IADtD;AAC4D,gBAAQ,IADpE;AAEC,cAAM,IAFP;AAEa,cAAM,IAFnB;AAEyB,cAAM,IAF/B;AAEqC,cAAM,IAF3C;AAEiD,cAAM,IAFvD;AAE6D,cAAM,IAFnE;AAGC,kBAAU,IAHX;AAGiB,kBAAU,IAH3B;AAGiC,cAAM,IAHvC;AAG6C,gBAAQ,IAHrD;AAG2D,eAAO,IAHlE;AAGwE,cAAM,IAH9E;AAIC,aAAK,IAJN;AAIY,eAAO,IAJnB;AAIyB,mBAAW,IAJpC;AAI0C,iBAAS,IAJnD;AAIyD,cAAM;AAJ/D,OANU;AAWf,YAAM;AAAC,cAAM,IAAP;AAAa,cAAM;AAAnB,OAXS;AAYf,YAAM;AAAC,cAAM,IAAP;AAAa,cAAM;AAAnB,OAZS;AAaf,eAAS;AAAC,iBAAS,IAAV;AAAgB,iBAAS;AAAzB,OAbM;AAcf,YAAM;AAAC,cAAM,IAAP;AAAa,cAAM;AAAnB,OAdS;AAef,eAAS;AAAC,iBAAS;AAAV,OAfM;AAgBf,YAAM;AAAC,cAAM,IAAP;AAAa,cAAM;AAAnB,OAhBS;AAiBf,eAAS;AAAC,iBAAS,IAAV;AAAgB,iBAAS;AAAzB,OAjBM;AAkBf,YAAM;AAAC,cAAM;AAAP;AAlBS,KARF;AA4BfC,IAAAA,WAAW,EAAE;AAAC,aAAO;AAAR,KA5BE;AA6BfC,IAAAA,aAAa,EAAE,IA7BA;AA8BfC,IAAAA,YAAY,EAAE,IA9BC;AA+BfC,IAAAA,QAAQ,EAAE;AA/BK,GAAjB;AAkCA,MAAIC,SAAS,GAAG;AACdP,IAAAA,eAAe,EAAE,EADH;AAEdC,IAAAA,gBAAgB,EAAE,EAFJ;AAGdC,IAAAA,eAAe,EAAE,EAHH;AAIdC,IAAAA,WAAW,EAAE,EAJC;AAKdC,IAAAA,aAAa,EAAE,KALD;AAMdC,IAAAA,YAAY,EAAE,KANA;AAOdG,IAAAA,mBAAmB,EAAE,KAPP;AAQdF,IAAAA,QAAQ,EAAE;AARI,GAAhB;AAWAR,EAAAA,UAAU,CAACW,UAAX,CAAsB,KAAtB,EAA6B,UAASC,UAAT,EAAqBC,OAArB,EAA8B;AACzD,QAAIC,UAAU,GAAGF,UAAU,CAACE,UAA5B;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,QAAQ,GAAGH,OAAO,CAACI,QAAR,GAAmBhB,UAAnB,GAAgCQ,SAA/C;;AACA,SAAK,IAAIS,IAAT,IAAiBF,QAAjB;AAA2BD,MAAAA,MAAM,CAACG,IAAD,CAAN,GAAeF,QAAQ,CAACE,IAAD,CAAvB;AAA3B;;AACA,SAAK,IAAIA,IAAT,IAAiBL,OAAjB;AAA0BE,MAAAA,MAAM,CAACG,IAAD,CAAN,GAAeL,OAAO,CAACK,IAAD,CAAtB;AAA1B,KALyD,CAOzD;;;AACA,QAAIC,IAAJ,EAAUC,QAAV;;AAEA,aAASC,MAAT,CAAgBC,MAAhB,EAAwBC,KAAxB,EAA+B;AAC7B,eAASC,KAAT,CAAeC,MAAf,EAAuB;AACrBF,QAAAA,KAAK,CAACG,QAAN,GAAiBD,MAAjB;AACA,eAAOA,MAAM,CAACH,MAAD,EAASC,KAAT,CAAb;AACD;;AAED,UAAII,EAAE,GAAGL,MAAM,CAACM,IAAP,EAAT;;AACA,UAAID,EAAE,IAAI,GAAV,EAAe;AACb,YAAIL,MAAM,CAACO,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnB,cAAIP,MAAM,CAACO,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnB,gBAAIP,MAAM,CAACQ,KAAP,CAAa,QAAb,CAAJ,EAA4B,OAAON,KAAK,CAACO,OAAO,CAAC,MAAD,EAAS,KAAT,CAAR,CAAZ,CAA5B,KACK,OAAO,IAAP;AACN,WAHD,MAGO,IAAIT,MAAM,CAACQ,KAAP,CAAa,IAAb,CAAJ,EAAwB;AAC7B,mBAAON,KAAK,CAACO,OAAO,CAAC,SAAD,EAAY,KAAZ,CAAR,CAAZ;AACD,WAFM,MAEA,IAAIT,MAAM,CAACQ,KAAP,CAAa,SAAb,EAAwB,IAAxB,EAA8B,IAA9B,CAAJ,EAAyC;AAC9CR,YAAAA,MAAM,CAACU,QAAP,CAAgB,WAAhB;AACA,mBAAOR,KAAK,CAACS,OAAO,CAAC,CAAD,CAAR,CAAZ;AACD,WAHM,MAGA;AACL,mBAAO,IAAP;AACD;AACF,SAZD,MAYO,IAAIX,MAAM,CAACO,GAAP,CAAW,GAAX,CAAJ,EAAqB;AAC1BP,UAAAA,MAAM,CAACU,QAAP,CAAgB,WAAhB;AACAT,UAAAA,KAAK,CAACG,QAAN,GAAiBK,OAAO,CAAC,MAAD,EAAS,IAAT,CAAxB;AACA,iBAAO,MAAP;AACD,SAJM,MAIA;AACLZ,UAAAA,IAAI,GAAGG,MAAM,CAACO,GAAP,CAAW,GAAX,IAAkB,UAAlB,GAA+B,SAAtC;AACAN,UAAAA,KAAK,CAACG,QAAN,GAAiBQ,KAAjB;AACA,iBAAO,aAAP;AACD;AACF,OAtBD,MAsBO,IAAIP,EAAE,IAAI,GAAV,EAAe;AACpB,YAAIQ,EAAJ;;AACA,YAAIb,MAAM,CAACO,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnB,cAAIP,MAAM,CAACO,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnBM,YAAAA,EAAE,GAAGb,MAAM,CAACU,QAAP,CAAgB,YAAhB,KAAiCV,MAAM,CAACO,GAAP,CAAW,GAAX,CAAtC;AACD,WAFD,MAEO;AACLM,YAAAA,EAAE,GAAGb,MAAM,CAACU,QAAP,CAAgB,MAAhB,KAA2BV,MAAM,CAACO,GAAP,CAAW,GAAX,CAAhC;AACD;AACF,SAND,MAMO;AACLM,UAAAA,EAAE,GAAGb,MAAM,CAACU,QAAP,CAAgB,WAAhB,KAAgCV,MAAM,CAACO,GAAP,CAAW,GAAX,CAArC;AACD;;AACD,eAAOM,EAAE,GAAG,MAAH,GAAY,OAArB;AACD,OAZM,MAYA;AACLb,QAAAA,MAAM,CAACU,QAAP,CAAgB,OAAhB;AACA,eAAO,IAAP;AACD;AACF;;AACDX,IAAAA,MAAM,CAACe,QAAP,GAAkB,IAAlB;;AAEA,aAASF,KAAT,CAAeZ,MAAf,EAAuBC,KAAvB,EAA8B;AAC5B,UAAII,EAAE,GAAGL,MAAM,CAACM,IAAP,EAAT;;AACA,UAAID,EAAE,IAAI,GAAN,IAAcA,EAAE,IAAI,GAAN,IAAaL,MAAM,CAACO,GAAP,CAAW,GAAX,CAA/B,EAAiD;AAC/CN,QAAAA,KAAK,CAACG,QAAN,GAAiBL,MAAjB;AACAF,QAAAA,IAAI,GAAGQ,EAAE,IAAI,GAAN,GAAY,QAAZ,GAAuB,cAA9B;AACA,eAAO,aAAP;AACD,OAJD,MAIO,IAAIA,EAAE,IAAI,GAAV,EAAe;AACpBR,QAAAA,IAAI,GAAG,QAAP;AACA,eAAO,IAAP;AACD,OAHM,MAGA,IAAIQ,EAAE,IAAI,GAAV,EAAe;AACpBJ,QAAAA,KAAK,CAACG,QAAN,GAAiBL,MAAjB;AACAE,QAAAA,KAAK,CAACA,KAAN,GAAcc,SAAd;AACAd,QAAAA,KAAK,CAACe,OAAN,GAAgBf,KAAK,CAACgB,QAAN,GAAiB,IAAjC;AACA,YAAIX,IAAI,GAAGL,KAAK,CAACG,QAAN,CAAeJ,MAAf,EAAuBC,KAAvB,CAAX;AACA,eAAOK,IAAI,GAAGA,IAAI,GAAG,YAAV,GAAyB,WAApC;AACD,OANM,MAMA,IAAI,SAASY,IAAT,CAAcb,EAAd,CAAJ,EAAuB;AAC5BJ,QAAAA,KAAK,CAACG,QAAN,GAAiBe,WAAW,CAACd,EAAD,CAA5B;AACAJ,QAAAA,KAAK,CAACmB,cAAN,GAAuBpB,MAAM,CAACqB,MAAP,EAAvB;AACA,eAAOpB,KAAK,CAACG,QAAN,CAAeJ,MAAf,EAAuBC,KAAvB,CAAP;AACD,OAJM,MAIA;AACLD,QAAAA,MAAM,CAACQ,KAAP,CAAa,0CAAb;AACA,eAAO,MAAP;AACD;AACF;;AAED,aAASW,WAAT,CAAqBG,KAArB,EAA4B;AAC1B,UAAIC,OAAO,GAAG,SAAVA,OAAU,CAASvB,MAAT,EAAiBC,KAAjB,EAAwB;AACpC,eAAO,CAACD,MAAM,CAACwB,GAAP,EAAR,EAAsB;AACpB,cAAIxB,MAAM,CAACM,IAAP,MAAiBgB,KAArB,EAA4B;AAC1BrB,YAAAA,KAAK,CAACG,QAAN,GAAiBQ,KAAjB;AACA;AACD;AACF;;AACD,eAAO,QAAP;AACD,OARD;;AASAW,MAAAA,OAAO,CAACE,aAAR,GAAwB,IAAxB;AACA,aAAOF,OAAP;AACD;;AAED,aAASd,OAAT,CAAiBiB,KAAjB,EAAwBC,UAAxB,EAAoC;AAClC,aAAO,UAAS3B,MAAT,EAAiBC,KAAjB,EAAwB;AAC7B,eAAO,CAACD,MAAM,CAACwB,GAAP,EAAR,EAAsB;AACpB,cAAIxB,MAAM,CAACQ,KAAP,CAAamB,UAAb,CAAJ,EAA8B;AAC5B1B,YAAAA,KAAK,CAACG,QAAN,GAAiBL,MAAjB;AACA;AACD;;AACDC,UAAAA,MAAM,CAACM,IAAP;AACD;;AACD,eAAOoB,KAAP;AACD,OATD;AAUD;;AAED,aAASf,OAAT,CAAiBiB,KAAjB,EAAwB;AACtB,aAAO,UAAS5B,MAAT,EAAiBC,KAAjB,EAAwB;AAC7B,YAAII,EAAJ;;AACA,eAAO,CAACA,EAAE,GAAGL,MAAM,CAACM,IAAP,EAAN,KAAwB,IAA/B,EAAqC;AACnC,cAAID,EAAE,IAAI,GAAV,EAAe;AACbJ,YAAAA,KAAK,CAACG,QAAN,GAAiBO,OAAO,CAACiB,KAAK,GAAG,CAAT,CAAxB;AACA,mBAAO3B,KAAK,CAACG,QAAN,CAAeJ,MAAf,EAAuBC,KAAvB,CAAP;AACD,WAHD,MAGO,IAAII,EAAE,IAAI,GAAV,EAAe;AACpB,gBAAIuB,KAAK,IAAI,CAAb,EAAgB;AACd3B,cAAAA,KAAK,CAACG,QAAN,GAAiBL,MAAjB;AACA;AACD,aAHD,MAGO;AACLE,cAAAA,KAAK,CAACG,QAAN,GAAiBO,OAAO,CAACiB,KAAK,GAAG,CAAT,CAAxB;AACA,qBAAO3B,KAAK,CAACG,QAAN,CAAeJ,MAAf,EAAuBC,KAAvB,CAAP;AACD;AACF;AACF;;AACD,eAAO,MAAP;AACD,OAjBD;AAkBD;;AAED,aAAS4B,OAAT,CAAiB5B,KAAjB,EAAwBe,OAAxB,EAAiCc,WAAjC,EAA8C;AAC5C,WAAKC,IAAL,GAAY9B,KAAK,CAAC+B,OAAlB;AACA,WAAKhB,OAAL,GAAeA,OAAf;AACA,WAAKiB,MAAL,GAAchC,KAAK,CAACiC,QAApB;AACA,WAAKJ,WAAL,GAAmBA,WAAnB;AACA,UAAIrC,MAAM,CAACV,WAAP,CAAmBoD,cAAnB,CAAkCnB,OAAlC,KAA+Cf,KAAK,CAAC+B,OAAN,IAAiB/B,KAAK,CAAC+B,OAAN,CAAcI,QAAlF,EACE,KAAKA,QAAL,GAAgB,IAAhB;AACH;;AACD,aAASC,UAAT,CAAoBpC,KAApB,EAA2B;AACzB,UAAIA,KAAK,CAAC+B,OAAV,EAAmB/B,KAAK,CAAC+B,OAAN,GAAgB/B,KAAK,CAAC+B,OAAN,CAAcD,IAA9B;AACpB;;AACD,aAASO,eAAT,CAAyBrC,KAAzB,EAAgCsC,WAAhC,EAA6C;AAC3C,UAAIC,aAAJ;;AACA,aAAO,IAAP,EAAa;AACX,YAAI,CAACvC,KAAK,CAAC+B,OAAX,EAAoB;AAClB;AACD;;AACDQ,QAAAA,aAAa,GAAGvC,KAAK,CAAC+B,OAAN,CAAchB,OAA9B;;AACA,YAAI,CAACvB,MAAM,CAACX,eAAP,CAAuBqD,cAAvB,CAAsCK,aAAtC,CAAD,IACA,CAAC/C,MAAM,CAACX,eAAP,CAAuB0D,aAAvB,EAAsCL,cAAtC,CAAqDI,WAArD,CADL,EACwE;AACtE;AACD;;AACDF,QAAAA,UAAU,CAACpC,KAAD,CAAV;AACD;AACF;;AAED,aAASc,SAAT,CAAmBlB,IAAnB,EAAyBG,MAAzB,EAAiCC,KAAjC,EAAwC;AACtC,UAAIJ,IAAI,IAAI,SAAZ,EAAuB;AACrBI,QAAAA,KAAK,CAACgB,QAAN,GAAiBjB,MAAM,CAACqB,MAAP,EAAjB;AACA,eAAOoB,YAAP;AACD,OAHD,MAGO,IAAI5C,IAAI,IAAI,UAAZ,EAAwB;AAC7B,eAAO6C,iBAAP;AACD,OAFM,MAEA;AACL,eAAO3B,SAAP;AACD;AACF;;AACD,aAAS0B,YAAT,CAAsB5C,IAAtB,EAA4BG,MAA5B,EAAoCC,KAApC,EAA2C;AACzC,UAAIJ,IAAI,IAAI,MAAZ,EAAoB;AAClBI,QAAAA,KAAK,CAACe,OAAN,GAAgBhB,MAAM,CAAC2C,OAAP,EAAhB;AACA7C,QAAAA,QAAQ,GAAG,KAAX;AACA,eAAO8C,SAAP;AACD,OAJD,MAIO,IAAInD,MAAM,CAACL,mBAAP,IAA8BS,IAAI,IAAI,QAA1C,EAAoD;AACzDC,QAAAA,QAAQ,GAAG,aAAX;AACA,eAAO8C,SAAS,CAAC/C,IAAD,EAAOG,MAAP,EAAeC,KAAf,CAAhB;AACD,OAHM,MAGA;AACLH,QAAAA,QAAQ,GAAG,OAAX;AACA,eAAO2C,YAAP;AACD;AACF;;AACD,aAASC,iBAAT,CAA2B7C,IAA3B,EAAiCG,MAAjC,EAAyCC,KAAzC,EAAgD;AAC9C,UAAIJ,IAAI,IAAI,MAAZ,EAAoB;AAClB,YAAImB,OAAO,GAAGhB,MAAM,CAAC2C,OAAP,EAAd;AACA,YAAI1C,KAAK,CAAC+B,OAAN,IAAiB/B,KAAK,CAAC+B,OAAN,CAAchB,OAAd,IAAyBA,OAA1C,IACAvB,MAAM,CAACZ,gBAAP,CAAwBsD,cAAxB,CAAuClC,KAAK,CAAC+B,OAAN,CAAchB,OAArD,CADJ,EAEEqB,UAAU,CAACpC,KAAD,CAAV;;AACF,YAAKA,KAAK,CAAC+B,OAAN,IAAiB/B,KAAK,CAAC+B,OAAN,CAAchB,OAAd,IAAyBA,OAA3C,IAAuDvB,MAAM,CAACoD,YAAP,KAAwB,KAAnF,EAA0F;AACxF/C,UAAAA,QAAQ,GAAG,KAAX;AACA,iBAAOgD,UAAP;AACD,SAHD,MAGO;AACLhD,UAAAA,QAAQ,GAAG,WAAX;AACA,iBAAOiD,aAAP;AACD;AACF,OAZD,MAYO,IAAItD,MAAM,CAACL,mBAAP,IAA8BS,IAAI,IAAI,QAA1C,EAAoD;AACzDC,QAAAA,QAAQ,GAAG,aAAX;AACA,eAAOgD,UAAU,CAACjD,IAAD,EAAOG,MAAP,EAAeC,KAAf,CAAjB;AACD,OAHM,MAGA;AACLH,QAAAA,QAAQ,GAAG,OAAX;AACA,eAAOiD,aAAP;AACD;AACF;;AAED,aAASD,UAAT,CAAoBjD,IAApB,EAA0BmD,OAA1B,EAAmC/C,KAAnC,EAA0C;AACxC,UAAIJ,IAAI,IAAI,QAAZ,EAAsB;AACpBC,QAAAA,QAAQ,GAAG,OAAX;AACA,eAAOgD,UAAP;AACD;;AACDT,MAAAA,UAAU,CAACpC,KAAD,CAAV;AACA,aAAOc,SAAP;AACD;;AACD,aAASgC,aAAT,CAAuBlD,IAAvB,EAA6BG,MAA7B,EAAqCC,KAArC,EAA4C;AAC1CH,MAAAA,QAAQ,GAAG,OAAX;AACA,aAAOgD,UAAU,CAACjD,IAAD,EAAOG,MAAP,EAAeC,KAAf,CAAjB;AACD;;AAED,aAAS2C,SAAT,CAAmB/C,IAAnB,EAAyBmD,OAAzB,EAAkC/C,KAAlC,EAAyC;AACvC,UAAIJ,IAAI,IAAI,MAAZ,EAAoB;AAClBC,QAAAA,QAAQ,GAAG,WAAX;AACA,eAAOmD,WAAP;AACD,OAHD,MAGO,IAAIpD,IAAI,IAAI,QAAR,IAAoBA,IAAI,IAAI,cAAhC,EAAgD;AACrD,YAAImB,OAAO,GAAGf,KAAK,CAACe,OAApB;AAAA,YAA6BC,QAAQ,GAAGhB,KAAK,CAACgB,QAA9C;AACAhB,QAAAA,KAAK,CAACe,OAAN,GAAgBf,KAAK,CAACgB,QAAN,GAAiB,IAAjC;;AACA,YAAIpB,IAAI,IAAI,cAAR,IACAJ,MAAM,CAACb,eAAP,CAAuBuD,cAAvB,CAAsCnB,OAAtC,CADJ,EACoD;AAClDsB,UAAAA,eAAe,CAACrC,KAAD,EAAQe,OAAR,CAAf;AACD,SAHD,MAGO;AACLsB,UAAAA,eAAe,CAACrC,KAAD,EAAQe,OAAR,CAAf;AACAf,UAAAA,KAAK,CAAC+B,OAAN,GAAgB,IAAIH,OAAJ,CAAY5B,KAAZ,EAAmBe,OAAnB,EAA4BC,QAAQ,IAAIhB,KAAK,CAACiC,QAA9C,CAAhB;AACD;;AACD,eAAOnB,SAAP;AACD;;AACDjB,MAAAA,QAAQ,GAAG,OAAX;AACA,aAAO8C,SAAP;AACD;;AACD,aAASK,WAAT,CAAqBpD,IAArB,EAA2BG,MAA3B,EAAmCC,KAAnC,EAA0C;AACxC,UAAIJ,IAAI,IAAI,QAAZ,EAAsB,OAAOqD,cAAP;AACtB,UAAI,CAACzD,MAAM,CAACR,YAAZ,EAA0Ba,QAAQ,GAAG,OAAX;AAC1B,aAAO8C,SAAS,CAAC/C,IAAD,EAAOG,MAAP,EAAeC,KAAf,CAAhB;AACD;;AACD,aAASiD,cAAT,CAAwBrD,IAAxB,EAA8BG,MAA9B,EAAsCC,KAAtC,EAA6C;AAC3C,UAAIJ,IAAI,IAAI,QAAZ,EAAsB,OAAOsD,kBAAP;;AACtB,UAAItD,IAAI,IAAI,MAAR,IAAkBJ,MAAM,CAACT,aAA7B,EAA4C;AAACc,QAAAA,QAAQ,GAAG,QAAX;AAAqB,eAAO8C,SAAP;AAAkB;;AACpF9C,MAAAA,QAAQ,GAAG,OAAX;AACA,aAAO8C,SAAS,CAAC/C,IAAD,EAAOG,MAAP,EAAeC,KAAf,CAAhB;AACD;;AACD,aAASkD,kBAAT,CAA4BtD,IAA5B,EAAkCG,MAAlC,EAA0CC,KAA1C,EAAiD;AAC/C,UAAIJ,IAAI,IAAI,QAAZ,EAAsB,OAAOsD,kBAAP;AACtB,aAAOP,SAAS,CAAC/C,IAAD,EAAOG,MAAP,EAAeC,KAAf,CAAhB;AACD;;AAED,WAAO;AACLmD,MAAAA,UAAU,EAAE,oBAASC,UAAT,EAAqB;AAC/B,YAAIpD,KAAK,GAAG;AAACG,UAAAA,QAAQ,EAAEL,MAAX;AACCE,UAAAA,KAAK,EAAEc,SADR;AAECmB,UAAAA,QAAQ,EAAEmB,UAAU,IAAI,CAFzB;AAGCrC,UAAAA,OAAO,EAAE,IAHV;AAGgBC,UAAAA,QAAQ,EAAE,IAH1B;AAICe,UAAAA,OAAO,EAAE;AAJV,SAAZ;AAKA,YAAIqB,UAAU,IAAI,IAAlB,EAAwBpD,KAAK,CAACoD,UAAN,GAAmBA,UAAnB;AACxB,eAAOpD,KAAP;AACD,OATI;AAWLqD,MAAAA,KAAK,EAAE,eAAStD,MAAT,EAAiBC,KAAjB,EAAwB;AAC7B,YAAI,CAACA,KAAK,CAACe,OAAP,IAAkBhB,MAAM,CAACuD,GAAP,EAAtB,EACEtD,KAAK,CAACiC,QAAN,GAAiBlC,MAAM,CAACwD,WAAP,EAAjB;AAEF,YAAIxD,MAAM,CAACyD,QAAP,EAAJ,EAAuB,OAAO,IAAP;AACvB5D,QAAAA,IAAI,GAAG,IAAP;AACA,YAAI6B,KAAK,GAAGzB,KAAK,CAACG,QAAN,CAAeJ,MAAf,EAAuBC,KAAvB,CAAZ;;AACA,YAAI,CAACyB,KAAK,IAAI7B,IAAV,KAAmB6B,KAAK,IAAI,SAAhC,EAA2C;AACzC5B,UAAAA,QAAQ,GAAG,IAAX;AACAG,UAAAA,KAAK,CAACA,KAAN,GAAcA,KAAK,CAACA,KAAN,CAAYJ,IAAI,IAAI6B,KAApB,EAA2B1B,MAA3B,EAAmCC,KAAnC,CAAd;AACA,cAAIH,QAAJ,EACE4B,KAAK,GAAG5B,QAAQ,IAAI,OAAZ,GAAsB4B,KAAK,GAAG,QAA9B,GAAyC5B,QAAjD;AACH;;AACD,eAAO4B,KAAP;AACD,OAzBI;AA2BLO,MAAAA,MAAM,EAAE,gBAAShC,KAAT,EAAgByD,SAAhB,EAA2BC,QAA3B,EAAqC;AAC3C,YAAI3B,OAAO,GAAG/B,KAAK,CAAC+B,OAApB,CAD2C,CAE3C;;AACA,YAAI/B,KAAK,CAACG,QAAN,CAAeqB,aAAnB,EAAkC;AAChC,cAAIxB,KAAK,CAACgB,QAAN,IAAkBhB,KAAK,CAACiC,QAA5B,EACE,OAAOjC,KAAK,CAACmB,cAAN,GAAuB,CAA9B,CADF,KAGE,OAAOnB,KAAK,CAACiC,QAAN,GAAiB1C,UAAxB;AACH;;AACD,YAAIwC,OAAO,IAAIA,OAAO,CAACI,QAAvB,EAAiC,OAAO1D,UAAU,CAACkF,IAAlB;AACjC,YAAI3D,KAAK,CAACG,QAAN,IAAkBQ,KAAlB,IAA2BX,KAAK,CAACG,QAAN,IAAkBL,MAAjD,EACE,OAAO4D,QAAQ,GAAGA,QAAQ,CAACnD,KAAT,CAAe,QAAf,EAAyB,CAAzB,EAA4BqD,MAA/B,GAAwC,CAAvD,CAXyC,CAY3C;;AACA,YAAI5D,KAAK,CAACe,OAAV,EAAmB;AACjB,cAAIvB,MAAM,CAACqE,yBAAP,KAAqC,KAAzC,EACE,OAAO7D,KAAK,CAACgB,QAAN,GAAiBhB,KAAK,CAACe,OAAN,CAAc6C,MAA/B,GAAwC,CAA/C,CADF,KAGE,OAAO5D,KAAK,CAACgB,QAAN,GAAiBzB,UAAU,IAAIC,MAAM,CAACsE,wBAAP,IAAmC,CAAvC,CAAlC;AACH;;AACD,YAAItE,MAAM,CAACuE,UAAP,IAAqB,cAAc9C,IAAd,CAAmBwC,SAAnB,CAAzB,EAAwD,OAAO,CAAP;AACxD,YAAIO,QAAQ,GAAGP,SAAS,IAAI,sBAAsBQ,IAAtB,CAA2BR,SAA3B,CAA5B;;AACA,YAAIO,QAAQ,IAAIA,QAAQ,CAAC,CAAD,CAAxB,EAA6B;AAAE;AAC7B,iBAAOjC,OAAP,EAAgB;AACd,gBAAIA,OAAO,CAAChB,OAAR,IAAmBiD,QAAQ,CAAC,CAAD,CAA/B,EAAoC;AAClCjC,cAAAA,OAAO,GAAGA,OAAO,CAACD,IAAlB;AACA;AACD,aAHD,MAGO,IAAItC,MAAM,CAACZ,gBAAP,CAAwBsD,cAAxB,CAAuCH,OAAO,CAAChB,OAA/C,CAAJ,EAA6D;AAClEgB,cAAAA,OAAO,GAAGA,OAAO,CAACD,IAAlB;AACD,aAFM,MAEA;AACL;AACD;AACF;AACF,SAXD,MAWO,IAAIkC,QAAJ,EAAc;AAAE;AACrB,iBAAOjC,OAAP,EAAgB;AACd,gBAAImC,QAAQ,GAAG1E,MAAM,CAACX,eAAP,CAAuBkD,OAAO,CAAChB,OAA/B,CAAf;AACA,gBAAImD,QAAQ,IAAIA,QAAQ,CAAChC,cAAT,CAAwB8B,QAAQ,CAAC,CAAD,CAAhC,CAAhB,EACEjC,OAAO,GAAGA,OAAO,CAACD,IAAlB,CADF,KAGE;AACH;AACF;;AACD,eAAOC,OAAO,IAAIA,OAAO,CAACD,IAAnB,IAA2B,CAACC,OAAO,CAACF,WAA3C;AACEE,UAAAA,OAAO,GAAGA,OAAO,CAACD,IAAlB;AADF;;AAEA,YAAIC,OAAJ,EAAa,OAAOA,OAAO,CAACC,MAAR,GAAiBzC,UAAxB,CAAb,KACK,OAAOS,KAAK,CAACoD,UAAN,IAAoB,CAA3B;AACN,OAxEI;AA0ELe,MAAAA,aAAa,EAAE,eA1EV;AA2ELC,MAAAA,iBAAiB,EAAE,MA3Ed;AA4ELC,MAAAA,eAAe,EAAE,KA5EZ;AA8ELC,MAAAA,aAAa,EAAE9E,MAAM,CAACE,QAAP,GAAkB,MAAlB,GAA2B,KA9ErC;AA+EL6E,MAAAA,UAAU,EAAE/E,MAAM,CAACE,QAAP,GAAkB,MAAlB,GAA2B,KA/ElC;AAiFL8E,MAAAA,aAAa,EAAE,uBAASxE,KAAT,EAAgB;AAC7B,YAAIA,KAAK,CAACA,KAAN,IAAeiD,cAAnB,EACEjD,KAAK,CAACA,KAAN,GAAc2C,SAAd;AACH,OApFI;AAsFL8B,MAAAA,aAAa,EAAE,uBAASzE,KAAT,EAAgB;AAC7B,eAAOA,KAAK,CAACe,OAAN,GAAgB;AAAC2D,UAAAA,IAAI,EAAE1E,KAAK,CAACe,OAAb;AAAsB4D,UAAAA,KAAK,EAAE3E,KAAK,CAACJ,IAAN,IAAc;AAA3C,SAAhB,GAAyE,IAAhF;AACD,OAxFI;AA0FLgF,MAAAA,iBAAiB,EAAE,2BAAS5E,KAAT,EAAgB;AACjC,YAAI+B,OAAO,GAAG,EAAd;;AACA,aAAK,IAAI8C,EAAE,GAAG7E,KAAK,CAAC+B,OAApB,EAA6B8C,EAA7B,EAAiCA,EAAE,GAAGA,EAAE,CAAC/C,IAAzC;AACE,cAAI+C,EAAE,CAAC9D,OAAP,EAAgBgB,OAAO,CAAC+C,IAAR,CAAaD,EAAE,CAAC9D,OAAhB;AADlB;;AAEA,eAAOgB,OAAO,CAACgD,OAAR,EAAP;AACD;AA/FI,KAAP;AAiGD,GA3VD;AA6VAtG,EAAAA,UAAU,CAACuG,UAAX,CAAsB,UAAtB,EAAkC,KAAlC;AACAvG,EAAAA,UAAU,CAACuG,UAAX,CAAsB,iBAAtB,EAAyC,KAAzC;AACA,MAAI,CAACvG,UAAU,CAACwG,SAAX,CAAqB/C,cAArB,CAAoC,WAApC,CAAL,EACEzD,UAAU,CAACuG,UAAX,CAAsB,WAAtB,EAAmC;AAACN,IAAAA,IAAI,EAAE,KAAP;AAAchF,IAAAA,QAAQ,EAAE;AAAxB,GAAnC;AAED,CAzZD","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        if (cx.tagName) context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n"]},"metadata":{},"sourceType":"script"}