{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.noop = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.bottom = bottom;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.childrenEqual = childrenEqual;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.correctBounds = correctBounds;\nexports.getLayoutItem = getLayoutItem;\nexports.getFirstCollision = getFirstCollision;\nexports.getAllCollisions = getAllCollisions;\nexports.getStatics = getStatics;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.perc = perc;\nexports.setTransform = setTransform;\nexports.setTopLeft = setTopLeft;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.autoBindHandlers = autoBindHandlers;\n\nvar _lodash = require(\"lodash.isequal\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout) {\n  var max = 0,\n      bottomY = void 0;\n\n  for (var _i = 0, len = layout.length; _i < len; _i++) {\n    bottomY = layout[_i].y + layout[_i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout) {\n  var newLayout = Array(layout.length);\n\n  for (var _i2 = 0, len = layout.length; _i2 < len; _i2++) {\n    newLayout[_i2] = cloneLayoutItem(layout[_i2]);\n  }\n\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem) {\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a, b) {\n  return (0, _lodash2.default)(_react2.default.Children.map(a, function (c) {\n    return c.key;\n  }), _react2.default.Children.map(b, function (c) {\n    return c.key;\n  }));\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1, l2) {\n  if (l1 === l2) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout, compactType, cols) {\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var _i3 = 0, len = sorted.length; _i3 < len; _i3++) {\n    var l = cloneLayoutItem(sorted[_i3]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[_i3])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.indexOf(item); // Go through each item we collide with.\n\n  for (var _i4 = itemIndex + 1; _i4 < layout.length; _i4++) {\n    var otherItem = layout[_i4]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n */\n\n\nfunction compactItem(compareWith, l, compactType, cols, fullLayout) {\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element left as far as it can go without colliding.\n\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides = void 0;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout, bounds) {\n  var collidesWith = getStatics(layout);\n\n  for (var _i5 = 0, len = layout.length; _i5 < len; _i5++) {\n    var l = layout[_i5]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout, id) {\n  for (var _i6 = 0, len = layout.length; _i6 < len; _i6++) {\n    if (layout[_i6].i === id) return layout[_i6];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout, layoutItem) {\n  for (var _i7 = 0, len = layout.length; _i7 < len; _i7++) {\n    if (collides(layout[_i7], layoutItem)) return layout[_i7];\n  }\n}\n\nfunction getAllCollisions(layout, layoutItem) {\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout) {\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {\n  if (l.static) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \" + l.i + \" to [\" + String(x) + \",\" + String(y) + \"] from [\" + l.x + \",\" + l.y + \"]\");\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === 'number') l.x = x;\n  if (typeof y === 'number') l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === 'number' ? oldY >= y : compactType === \"horizontal\" && typeof x === 'number' ? oldX >= x : false;\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l); // There was a collision; abort\n\n  if (preventCollision && collisions.length) {\n    log(\"Collision prevented on \" + l.i + \", reverting.\");\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (var _i8 = 0, len = collisions.length; _i8 < len; _i8++) {\n    var collision = collisions[_i8];\n    log(\"Resolving collision between \" + l.i + \" at [\" + l.x + \",\" + l.y + \"] and \" + collision.i + \" at [\" + collision.x + \",\" + collision.y + \"]\"); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {\n  var compactH = compactType === \"horizontal\";\n  var compactV = compactType === \"vertical\";\n  var preventCollision = false; // we're already colliding\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \" + itemToMove.i + \" up to [\" + fakeItem.x + \",\" + fakeItem.y + \"].\");\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num) {\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height; // Replace unitless items with px\n\n  var translate = \"translate(\" + left + \"px,\" + top + \"px)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2) {\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: top + \"px\",\n    left: left + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout, compactType) {\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);else return sortLayoutItemsByRowCol(layout);\n}\n\nfunction sortLayoutItemsByRowCol(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n\nfunction sortLayoutItemsByColRow(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout, children, cols, compactType) {\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout = [];\n\n  _react2.default.Children.forEach(children, function (child, i) {\n    // Don't overwrite if it already exists.\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout[i] = cloneLayoutItem(exists);\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + // eslint-disable-line\n        \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n\n        layout[i] = cloneLayoutItem(_extends({}, g, {\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        layout[i] = cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        });\n      }\n    }\n  }); // Correct the layout.\n\n\n  layout = correctBounds(layout, {\n    cols: cols\n  });\n  layout = compact(layout, compactType, cols);\n  return layout;\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout) {\n  var contextName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var _i9 = 0, len = layout.length; _i9 < len; _i9++) {\n    var item = layout[_i9];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + _i9 + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n\n    if (item.i && typeof item.i !== \"string\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + _i9 + \"].i must be a string!\");\n    }\n\n    if (item.static !== undefined && typeof item.static !== \"boolean\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + _i9 + \"].static must be a boolean!\");\n    }\n  }\n} // Flow can't really figure this out, so we just use Object\n\n\nfunction autoBindHandlers(el, fns) {\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = exports.noop = function noop() {};","map":{"version":3,"sources":["/home/altius/QAT/fasp-core-ui/node_modules/react-grid-layout/build/utils.js"],"names":["exports","__esModule","noop","undefined","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","bottom","cloneLayout","cloneLayoutItem","childrenEqual","collides","compact","compactItem","correctBounds","getLayoutItem","getFirstCollision","getAllCollisions","getStatics","moveElement","moveElementAwayFromCollision","perc","setTransform","setTopLeft","sortLayoutItems","sortLayoutItemsByRowCol","sortLayoutItemsByColRow","synchronizeLayoutWithChildren","validateLayout","autoBindHandlers","_lodash","require","_lodash2","_interopRequireDefault","_react","_react2","obj","default","isProduction","process","env","NODE_ENV","DEBUG","layout","max","bottomY","_i","len","y","h","newLayout","Array","_i2","layoutItem","w","x","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","a","b","Children","map","c","l1","l2","compactType","cols","compareWith","sorted","out","_i3","l","push","indexOf","heightWidth","resolveCompactionCollision","item","moveToCoord","axis","sizeProp","itemIndex","_i4","otherItem","fullLayout","compactV","compactH","Math","min","bounds","collidesWith","_i5","id","_i6","_i7","filter","isUserAction","preventCollision","log","String","oldX","oldY","movingUp","reverse","collisions","_i8","collision","itemToMove","fakeItem","num","_ref","top","left","width","height","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","_ref2","concat","sort","initialLayout","children","forEach","child","exists","props","_grid","console","warn","g","contextName","subProps","isArray","Error","_i9","j","el","fns","bind","_console","apply"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.noop = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.bottom = bottom;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.childrenEqual = childrenEqual;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.correctBounds = correctBounds;\nexports.getLayoutItem = getLayoutItem;\nexports.getFirstCollision = getFirstCollision;\nexports.getAllCollisions = getAllCollisions;\nexports.getStatics = getStatics;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.perc = perc;\nexports.setTransform = setTransform;\nexports.setTopLeft = setTopLeft;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.autoBindHandlers = autoBindHandlers;\n\nvar _lodash = require(\"lodash.isequal\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout) {\n  var max = 0,\n      bottomY = void 0;\n  for (var _i = 0, len = layout.length; _i < len; _i++) {\n    bottomY = layout[_i].y + layout[_i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\n\nfunction cloneLayout(layout) {\n  var newLayout = Array(layout.length);\n  for (var _i2 = 0, len = layout.length; _i2 < len; _i2++) {\n    newLayout[_i2] = cloneLayoutItem(layout[_i2]);\n  }\n  return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem) {\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a, b) {\n  return (0, _lodash2.default)(_react2.default.Children.map(a, function (c) {\n    return c.key;\n  }), _react2.default.Children.map(b, function (c) {\n    return c.key;\n  }));\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1, l2) {\n  if (l1 === l2) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout, compactType, cols) {\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  var sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  var out = Array(layout.length);\n\n  for (var _i3 = 0, len = sorted.length; _i3 < len; _i3++) {\n    var l = cloneLayoutItem(sorted[_i3]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[_i3])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = { x: \"w\", y: \"h\" };\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.indexOf(item);\n\n  // Go through each item we collide with.\n  for (var _i4 = itemIndex + 1; _i4 < layout.length; _i4++) {\n    var otherItem = layout[_i4];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n */\nfunction compactItem(compareWith, l, compactType, cols, fullLayout) {\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  var collides = void 0;\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout, bounds) {\n  var collidesWith = getStatics(layout);\n  for (var _i5 = 0, len = layout.length; _i5 < len; _i5++) {\n    var l = layout[_i5];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout, id) {\n  for (var _i6 = 0, len = layout.length; _i6 < len; _i6++) {\n    if (layout[_i6].i === id) return layout[_i6];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout, layoutItem) {\n  for (var _i7 = 0, len = layout.length; _i7 < len; _i7++) {\n    if (collides(layout[_i7], layoutItem)) return layout[_i7];\n  }\n}\n\nfunction getAllCollisions(layout, layoutItem) {\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout) {\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {\n  if (l.static) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n\n  log(\"Moving element \" + l.i + \" to [\" + String(x) + \",\" + String(y) + \"] from [\" + l.x + \",\" + l.y + \"]\");\n  var oldX = l.x;\n  var oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === 'number') l.x = x;\n  if (typeof y === 'number') l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === 'number' ? oldY >= y : compactType === \"horizontal\" && typeof x === 'number' ? oldX >= x : false;\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n\n  // There was a collision; abort\n  if (preventCollision && collisions.length) {\n    log(\"Collision prevented on \" + l.i + \", reverting.\");\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  }\n\n  // Move each item that collides away from this element.\n  for (var _i8 = 0, len = collisions.length; _i8 < len; _i8++) {\n    var collision = collisions[_i8];\n    log(\"Resolving collision between \" + l.i + \" at [\" + l.x + \",\" + l.y + \"] and \" + collision.i + \" at [\" + collision.x + \",\" + collision.y + \"]\");\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {\n  var compactH = compactType === \"horizontal\";\n  var compactV = compactType === \"vertical\";\n  var preventCollision = false; // we're already colliding\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    var fakeItem = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \" + itemToMove.i + \" up to [\" + fakeItem.x + \",\" + fakeItem.y + \"].\");\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num) {\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n\n  // Replace unitless items with px\n  var translate = \"translate(\" + left + \"px,\" + top + \"px)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2) {\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n\n  return {\n    top: top + \"px\",\n    left: left + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout, compactType) {\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);else return sortLayoutItemsByRowCol(layout);\n}\n\nfunction sortLayoutItemsByRowCol(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\nfunction sortLayoutItemsByColRow(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout, children, cols, compactType) {\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  var layout = [];\n  _react2.default.Children.forEach(children, function (child, i) {\n    // Don't overwrite if it already exists.\n    var exists = getLayoutItem(initialLayout, String(child.key));\n    if (exists) {\n      layout[i] = cloneLayoutItem(exists);\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + // eslint-disable-line\n        \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n      var g = child.props[\"data-grid\"] || child.props._grid;\n\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        layout[i] = cloneLayoutItem(_extends({}, g, { i: child.key }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        layout[i] = cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        });\n      }\n    }\n  });\n\n  // Correct the layout.\n  layout = correctBounds(layout, { cols: cols });\n  layout = compact(layout, compactType, cols);\n\n  return layout;\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout) {\n  var contextName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (var _i9 = 0, len = layout.length; _i9 < len; _i9++) {\n    var item = layout[_i9];\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + _i9 + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n    if (item.i && typeof item.i !== \"string\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + _i9 + \"].i must be a string!\");\n    }\n    if (item.static !== undefined && typeof item.static !== \"boolean\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + _i9 + \"].static must be a boolean!\");\n    }\n  }\n}\n\n// Flow can't really figure this out, so we just use Object\nfunction autoBindHandlers(el, fns) {\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = exports.noop = function noop() {};"]},"metadata":{},"sourceType":"script"}