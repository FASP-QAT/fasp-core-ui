{"ast":null,"code":"'use strict';\n\nvar utils = require('../utils');\n\nfunction DataReader(data) {\n  this.data = data; // type : see implementation\n\n  this.length = data.length;\n  this.index = 0;\n  this.zero = 0;\n}\n\nDataReader.prototype = {\n  /**\n   * Check that the offset will not go too far.\n   * @param {string} offset the additional offset to check.\n   * @throws {Error} an Error if the offset is out of bounds.\n   */\n  checkOffset: function checkOffset(offset) {\n    this.checkIndex(this.index + offset);\n  },\n\n  /**\n   * Check that the specified index will not be too far.\n   * @param {string} newIndex the index to check.\n   * @throws {Error} an Error if the index is out of bounds.\n   */\n  checkIndex: function checkIndex(newIndex) {\n    if (this.length < this.zero + newIndex || newIndex < 0) {\n      throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n    }\n  },\n\n  /**\n   * Change the index.\n   * @param {number} newIndex The new index.\n   * @throws {Error} if the new index is out of the data.\n   */\n  setIndex: function setIndex(newIndex) {\n    this.checkIndex(newIndex);\n    this.index = newIndex;\n  },\n\n  /**\n   * Skip the next n bytes.\n   * @param {number} n the number of bytes to skip.\n   * @throws {Error} if the new index is out of the data.\n   */\n  skip: function skip(n) {\n    this.setIndex(this.index + n);\n  },\n\n  /**\n   * Get the byte at the specified index.\n   * @param {number} i the index to use.\n   * @return {number} a byte.\n   */\n  byteAt: function byteAt(i) {// see implementations\n  },\n\n  /**\n   * Get the next number with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {number} the corresponding number.\n   */\n  readInt: function readInt(size) {\n    var result = 0,\n        i;\n    this.checkOffset(size);\n\n    for (i = this.index + size - 1; i >= this.index; i--) {\n      result = (result << 8) + this.byteAt(i);\n    }\n\n    this.index += size;\n    return result;\n  },\n\n  /**\n   * Get the next string with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {string} the corresponding string.\n   */\n  readString: function readString(size) {\n    return utils.transformTo(\"string\", this.readData(size));\n  },\n\n  /**\n   * Get raw data without conversion, <size> bytes.\n   * @param {number} size the number of bytes to read.\n   * @return {Object} the raw data, implementation specific.\n   */\n  readData: function readData(size) {// see implementations\n  },\n\n  /**\n   * Find the last occurence of a zip signature (4 bytes).\n   * @param {string} sig the signature to find.\n   * @return {number} the index of the last occurence, -1 if not found.\n   */\n  lastIndexOfSignature: function lastIndexOfSignature(sig) {// see implementations\n  },\n\n  /**\n   * Read the signature (4 bytes) at the current position and compare it with sig.\n   * @param {string} sig the expected signature\n   * @return {boolean} true if the signature matches, false otherwise.\n   */\n  readAndCheckSignature: function readAndCheckSignature(sig) {// see implementations\n  },\n\n  /**\n   * Get the next date.\n   * @return {Date} the date.\n   */\n  readDate: function readDate() {\n    var dostime = this.readInt(4);\n    return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year\n    (dostime >> 21 & 0x0f) - 1, // month\n    dostime >> 16 & 0x1f, // day\n    dostime >> 11 & 0x1f, // hour\n    dostime >> 5 & 0x3f, // minute\n    (dostime & 0x1f) << 1)); // second\n  }\n};\nmodule.exports = DataReader;","map":{"version":3,"sources":["/home/altius/NodeJs/fasp-core-ui/node_modules/jszip/lib/reader/DataReader.js"],"names":["utils","require","DataReader","data","length","index","zero","prototype","checkOffset","offset","checkIndex","newIndex","Error","setIndex","skip","n","byteAt","i","readInt","size","result","readString","transformTo","readData","lastIndexOfSignature","sig","readAndCheckSignature","readDate","dostime","Date","UTC","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar utils = require('../utils');\n\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */\n    readAndCheckSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n"]},"metadata":{},"sourceType":"script"}