{"ast":null,"code":"'use strict';\n\nvar compressions = require('../compressions');\n\nvar ZipFileWorker = require('./ZipFileWorker');\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\n\n\nvar getCompression = function getCompression(fileCompression, zipCompression) {\n  var compressionName = fileCompression || zipCompression;\n  var compression = compressions[compressionName];\n\n  if (!compression) {\n    throw new Error(compressionName + \" is not a valid compression method !\");\n  }\n\n  return compression;\n};\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\n\n\nexports.generateWorker = function (zip, options, comment) {\n  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n  var entriesCount = 0;\n\n  try {\n    zip.forEach(function (relativePath, file) {\n      entriesCount++;\n      var compression = getCompression(file.options.compression, options.compression);\n      var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n      var dir = file.dir,\n          date = file.date;\n\n      file._compressWorker(compression, compressionOptions).withStreamInfo(\"file\", {\n        name: relativePath,\n        dir: dir,\n        date: date,\n        comment: file.comment || \"\",\n        unixPermissions: file.unixPermissions,\n        dosPermissions: file.dosPermissions\n      }).pipe(zipFileWorker);\n    });\n    zipFileWorker.entriesCount = entriesCount;\n  } catch (e) {\n    zipFileWorker.error(e);\n  }\n\n  return zipFileWorker;\n};","map":{"version":3,"sources":["/home/altius/NodeJs/fasp-core-ui/node_modules/jszip/lib/generate/index.js"],"names":["compressions","require","ZipFileWorker","getCompression","fileCompression","zipCompression","compressionName","compression","Error","exports","generateWorker","zip","options","comment","zipFileWorker","streamFiles","platform","encodeFileName","entriesCount","forEach","relativePath","file","compressionOptions","dir","date","_compressWorker","withStreamInfo","name","unixPermissions","dosPermissions","pipe","e","error"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA1B;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA3B;AAEA;;;;;;;;AAMA,IAAIE,cAAc,GAAG,SAAjBA,cAAiB,CAAUC,eAAV,EAA2BC,cAA3B,EAA2C;AAE5D,MAAIC,eAAe,GAAGF,eAAe,IAAIC,cAAzC;AACA,MAAIE,WAAW,GAAGP,YAAY,CAACM,eAAD,CAA9B;;AACA,MAAI,CAACC,WAAL,EAAkB;AACd,UAAM,IAAIC,KAAJ,CAAUF,eAAe,GAAG,sCAA5B,CAAN;AACH;;AACD,SAAOC,WAAP;AACH,CARD;AAUA;;;;;;;;AAMAE,OAAO,CAACC,cAAR,GAAyB,UAAUC,GAAV,EAAeC,OAAf,EAAwBC,OAAxB,EAAiC;AAEtD,MAAIC,aAAa,GAAG,IAAIZ,aAAJ,CAAkBU,OAAO,CAACG,WAA1B,EAAuCF,OAAvC,EAAgDD,OAAO,CAACI,QAAxD,EAAkEJ,OAAO,CAACK,cAA1E,CAApB;AACA,MAAIC,YAAY,GAAG,CAAnB;;AACA,MAAI;AAEAP,IAAAA,GAAG,CAACQ,OAAJ,CAAY,UAAUC,YAAV,EAAwBC,IAAxB,EAA8B;AACtCH,MAAAA,YAAY;AACZ,UAAIX,WAAW,GAAGJ,cAAc,CAACkB,IAAI,CAACT,OAAL,CAAaL,WAAd,EAA2BK,OAAO,CAACL,WAAnC,CAAhC;AACA,UAAIe,kBAAkB,GAAGD,IAAI,CAACT,OAAL,CAAaU,kBAAb,IAAmCV,OAAO,CAACU,kBAA3C,IAAiE,EAA1F;AACA,UAAIC,GAAG,GAAGF,IAAI,CAACE,GAAf;AAAA,UAAoBC,IAAI,GAAGH,IAAI,CAACG,IAAhC;;AAEAH,MAAAA,IAAI,CAACI,eAAL,CAAqBlB,WAArB,EAAkCe,kBAAlC,EACCI,cADD,CACgB,MADhB,EACwB;AACpBC,QAAAA,IAAI,EAAGP,YADa;AAEpBG,QAAAA,GAAG,EAAGA,GAFc;AAGpBC,QAAAA,IAAI,EAAGA,IAHa;AAIpBX,QAAAA,OAAO,EAAGQ,IAAI,CAACR,OAAL,IAAgB,EAJN;AAKpBe,QAAAA,eAAe,EAAGP,IAAI,CAACO,eALH;AAMpBC,QAAAA,cAAc,EAAGR,IAAI,CAACQ;AANF,OADxB,EASCC,IATD,CASMhB,aATN;AAUH,KAhBD;AAiBAA,IAAAA,aAAa,CAACI,YAAd,GAA6BA,YAA7B;AACH,GApBD,CAoBE,OAAOa,CAAP,EAAU;AACRjB,IAAAA,aAAa,CAACkB,KAAd,CAAoBD,CAApB;AACH;;AAED,SAAOjB,aAAP;AACH,CA7BD","sourcesContent":["'use strict';\n\nvar compressions = require('../compressions');\nvar ZipFileWorker = require('./ZipFileWorker');\n\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\nvar getCompression = function (fileCompression, zipCompression) {\n\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\nexports.generateWorker = function (zip, options, comment) {\n\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n\n        zip.forEach(function (relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n\n            file._compressWorker(compression, compressionOptions)\n            .withStreamInfo(\"file\", {\n                name : relativePath,\n                dir : dir,\n                date : date,\n                comment : file.comment || \"\",\n                unixPermissions : file.unixPermissions,\n                dosPermissions : file.dosPermissions\n            })\n            .pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n\n    return zipFileWorker;\n};\n"]},"metadata":{},"sourceType":"script"}