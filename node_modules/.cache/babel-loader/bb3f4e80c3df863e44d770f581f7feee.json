{"ast":null,"code":"'use strict';\n\nvar StreamHelper = require('./stream/StreamHelper');\n\nvar DataWorker = require('./stream/DataWorker');\n\nvar utf8 = require('./utf8');\n\nvar CompressedObject = require('./compressedObject');\n\nvar GenericWorker = require('./stream/GenericWorker');\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\n\n\nvar ZipObject = function ZipObject(name, data, options) {\n  this.name = name;\n  this.dir = options.dir;\n  this.date = options.date;\n  this.comment = options.comment;\n  this.unixPermissions = options.unixPermissions;\n  this.dosPermissions = options.dosPermissions;\n  this._data = data;\n  this._dataBinary = options.binary; // keep only the compression\n\n  this.options = {\n    compression: options.compression,\n    compressionOptions: options.compressionOptions\n  };\n};\n\nZipObject.prototype = {\n  /**\n   * Create an internal stream for the content of this object.\n   * @param {String} type the type of each chunk.\n   * @return StreamHelper the stream.\n   */\n  internalStream: function internalStream(type) {\n    var result = null,\n        outputType = \"string\";\n\n    try {\n      if (!type) {\n        throw new Error(\"No output type specified.\");\n      }\n\n      outputType = type.toLowerCase();\n      var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n\n      if (outputType === \"binarystring\" || outputType === \"text\") {\n        outputType = \"string\";\n      }\n\n      result = this._decompressWorker();\n      var isUnicodeString = !this._dataBinary;\n\n      if (isUnicodeString && !askUnicodeString) {\n        result = result.pipe(new utf8.Utf8EncodeWorker());\n      }\n\n      if (!isUnicodeString && askUnicodeString) {\n        result = result.pipe(new utf8.Utf8DecodeWorker());\n      }\n    } catch (e) {\n      result = new GenericWorker(\"error\");\n      result.error(e);\n    }\n\n    return new StreamHelper(result, outputType, \"\");\n  },\n\n  /**\n   * Prepare the content in the asked type.\n   * @param {String} type the type of the result.\n   * @param {Function} onUpdate a function to call on each internal update.\n   * @return Promise the promise of the result.\n   */\n  async: function async(type, onUpdate) {\n    return this.internalStream(type).accumulate(onUpdate);\n  },\n\n  /**\n   * Prepare the content as a nodejs stream.\n   * @param {String} type the type of each chunk.\n   * @param {Function} onUpdate a function to call on each internal update.\n   * @return Stream the stream.\n   */\n  nodeStream: function nodeStream(type, onUpdate) {\n    return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n  },\n\n  /**\n   * Return a worker for the compressed content.\n   * @private\n   * @param {Object} compression the compression object to use.\n   * @param {Object} compressionOptions the options to use when compressing.\n   * @return Worker the worker.\n   */\n  _compressWorker: function _compressWorker(compression, compressionOptions) {\n    if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {\n      return this._data.getCompressedWorker();\n    } else {\n      var result = this._decompressWorker();\n\n      if (!this._dataBinary) {\n        result = result.pipe(new utf8.Utf8EncodeWorker());\n      }\n\n      return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n    }\n  },\n\n  /**\n   * Return a worker for the decompressed content.\n   * @private\n   * @return Worker the worker.\n   */\n  _decompressWorker: function _decompressWorker() {\n    if (this._data instanceof CompressedObject) {\n      return this._data.getContentWorker();\n    } else if (this._data instanceof GenericWorker) {\n      return this._data;\n    } else {\n      return new DataWorker(this._data);\n    }\n  }\n};\nvar removedMethods = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"];\n\nvar removedFn = function removedFn() {\n  throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\n\nfor (var i = 0; i < removedMethods.length; i++) {\n  ZipObject.prototype[removedMethods[i]] = removedFn;\n}\n\nmodule.exports = ZipObject;","map":{"version":3,"sources":["/home/altius/NodeJs/fasp-core-ui/node_modules/jszip/lib/zipObject.js"],"names":["StreamHelper","require","DataWorker","utf8","CompressedObject","GenericWorker","ZipObject","name","data","options","dir","date","comment","unixPermissions","dosPermissions","_data","_dataBinary","binary","compression","compressionOptions","prototype","internalStream","type","result","outputType","Error","toLowerCase","askUnicodeString","_decompressWorker","isUnicodeString","pipe","Utf8EncodeWorker","Utf8DecodeWorker","e","error","async","onUpdate","accumulate","nodeStream","toNodejsStream","_compressWorker","magic","getCompressedWorker","createWorkerFrom","getContentWorker","removedMethods","removedFn","i","length","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar StreamHelper = require('./stream/StreamHelper');\nvar DataWorker = require('./stream/DataWorker');\nvar utf8 = require('./utf8');\nvar CompressedObject = require('./compressedObject');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression : options.compression,\n        compressionOptions : options.compressionOptions\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */\n    internalStream: function (type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n\n            var isUnicodeString = !this._dataBinary;\n\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n\n        return new StreamHelper(result, outputType, \"\");\n    },\n\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */\n    async: function (type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */\n    nodeStream: function (type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */\n    _compressWorker: function (compression, compressionOptions) {\n        if (\n            this._data instanceof CompressedObject &&\n            this._data.compression.magic === compression.magic\n        ) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if(!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */\n    _decompressWorker : function () {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\n\nvar removedMethods = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"];\nvar removedFn = function () {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\n\nfor(var i = 0; i < removedMethods.length; i++) {\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n"]},"metadata":{},"sourceType":"script"}