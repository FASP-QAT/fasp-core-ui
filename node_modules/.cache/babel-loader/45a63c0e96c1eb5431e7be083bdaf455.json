{"ast":null,"code":"'use strict'; // based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\n\nvar delimiter = '-'; // '\\x2D'\n\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\n\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */\n\nvar ucs2decode = function ucs2decode(string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n\n  while (counter < length) {\n    var value = string.charCodeAt(counter++);\n\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      var extra = string.charCodeAt(counter++);\n\n      if ((extra & 0xFC00) == 0xDC00) {\n        // Low surrogate.\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n\n  return output;\n};\n/**\n * Converts a digit/integer into a basic code point.\n */\n\n\nvar digitToBasic = function digitToBasic(digit) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26);\n};\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */\n\n\nvar adapt = function adapt(delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n\n  for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n    delta = floor(delta / baseMinusTMin);\n  }\n\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */\n// eslint-disable-next-line  max-statements\n\n\nvar encode = function encode(input) {\n  var output = []; // Convert the input in UCS-2 to an array of Unicode code points.\n\n  input = ucs2decode(input); // Cache the length.\n\n  var inputLength = input.length; // Initialize the state.\n\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n  var i, currentValue; // Handle the basic code points.\n\n  for (i = 0; i < input.length; i++) {\n    currentValue = input[i];\n\n    if (currentValue < 0x80) {\n      output.push(stringFromCharCode(currentValue));\n    }\n  }\n\n  var basicLength = output.length; // number of basic code points.\n\n  var handledCPCount = basicLength; // number of code points that have been handled;\n  // Finish the basic string with a delimiter unless it's empty.\n\n  if (basicLength) {\n    output.push(delimiter);\n  } // Main encoding loop:\n\n\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next larger one:\n    var m = maxInt;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n\n\n    var handledCPCountPlusOne = handledCPCount + 1;\n\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      throw RangeError(OVERFLOW_ERROR);\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n\n      if (currentValue < n && ++delta > maxInt) {\n        throw RangeError(OVERFLOW_ERROR);\n      }\n\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        var q = delta;\n\n        for (var k = base;;\n        /* no condition */\n        k += base) {\n          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (q < t) break;\n          var qMinusT = q - t;\n          var baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n          q = floor(qMinusT / baseMinusT);\n        }\n\n        output.push(stringFromCharCode(digitToBasic(q)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        ++handledCPCount;\n      }\n    }\n\n    ++delta;\n    ++n;\n  }\n\n  return output.join('');\n};\n\nmodule.exports = function (input) {\n  var encoded = [];\n  var labels = input.toLowerCase().replace(regexSeparators, \".\").split('.');\n  var i, label;\n\n  for (i = 0; i < labels.length; i++) {\n    label = labels[i];\n    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);\n  }\n\n  return encoded.join('.');\n};","map":{"version":3,"sources":["/home/altius/fasp-core-ui/node_modules/core-js/internals/string-punycode-to-ascii.js"],"names":["maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexNonASCII","regexSeparators","OVERFLOW_ERROR","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","ucs2decode","string","output","counter","length","value","charCodeAt","extra","push","digitToBasic","digit","adapt","delta","numPoints","firstTime","k","encode","input","inputLength","n","bias","i","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","RangeError","q","t","qMinusT","baseMinusT","join","module","exports","encoded","labels","toLowerCase","replace","split","label","test"],"mappings":"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","sourcesContent":["'use strict';\n// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */\nvar ucs2decode = function (string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n  while (counter < length) {\n    var value = string.charCodeAt(counter++);\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      var extra = string.charCodeAt(counter++);\n      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n  return output;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n */\nvar digitToBasic = function (digit) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */\nvar adapt = function (delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n  for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n    delta = floor(delta / baseMinusTMin);\n  }\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */\n// eslint-disable-next-line  max-statements\nvar encode = function (input) {\n  var output = [];\n\n  // Convert the input in UCS-2 to an array of Unicode code points.\n  input = ucs2decode(input);\n\n  // Cache the length.\n  var inputLength = input.length;\n\n  // Initialize the state.\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n  var i, currentValue;\n\n  // Handle the basic code points.\n  for (i = 0; i < input.length; i++) {\n    currentValue = input[i];\n    if (currentValue < 0x80) {\n      output.push(stringFromCharCode(currentValue));\n    }\n  }\n\n  var basicLength = output.length; // number of basic code points.\n  var handledCPCount = basicLength; // number of code points that have been handled;\n\n  // Finish the basic string with a delimiter unless it's empty.\n  if (basicLength) {\n    output.push(delimiter);\n  }\n\n  // Main encoding loop:\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next larger one:\n    var m = maxInt;\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    }\n\n    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n    var handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      throw RangeError(OVERFLOW_ERROR);\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue < n && ++delta > maxInt) {\n        throw RangeError(OVERFLOW_ERROR);\n      }\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        var q = delta;\n        for (var k = base; /* no condition */; k += base) {\n          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n          if (q < t) break;\n          var qMinusT = q - t;\n          var baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n          q = floor(qMinusT / baseMinusT);\n        }\n\n        output.push(stringFromCharCode(digitToBasic(q)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        ++handledCPCount;\n      }\n    }\n\n    ++delta;\n    ++n;\n  }\n  return output.join('');\n};\n\nmodule.exports = function (input) {\n  var encoded = [];\n  var labels = input.toLowerCase().replace(regexSeparators, '\\u002E').split('.');\n  var i, label;\n  for (i = 0; i < labels.length; i++) {\n    label = labels[i];\n    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);\n  }\n  return encoded.join('.');\n};\n"]},"metadata":{},"sourceType":"script"}