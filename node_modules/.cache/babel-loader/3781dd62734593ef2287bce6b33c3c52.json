{"ast":null,"code":"'use strict';\n\nvar utils = require('../utils');\n\nvar GenericWorker = require('../stream/GenericWorker');\n\nvar utf8 = require('../utf8');\n\nvar crc32 = require('../crc32');\n\nvar signature = require('../signature');\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\n\n\nvar decToHex = function decToHex(dec, bytes) {\n  var hex = \"\",\n      i;\n\n  for (i = 0; i < bytes; i++) {\n    hex += String.fromCharCode(dec & 0xff);\n    dec = dec >>> 8;\n  }\n\n  return hex;\n};\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\n\n\nvar generateUnixExternalFileAttr = function generateUnixExternalFileAttr(unixPermissions, isDir) {\n  var result = unixPermissions;\n\n  if (!unixPermissions) {\n    // I can't use octal values in strict mode, hence the hexa.\n    //  040775 => 0x41fd\n    // 0100664 => 0x81b4\n    result = isDir ? 0x41fd : 0x81b4;\n  }\n\n  return (result & 0xFFFF) << 16;\n};\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\n\n\nvar generateDosExternalFileAttr = function generateDosExternalFileAttr(dosPermissions, isDir) {\n  // the dir flag is already set for compatibility\n  return (dosPermissions || 0) & 0x3F;\n};\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with informations about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */\n\n\nvar generateZipParts = function generateZipParts(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n  var file = streamInfo['file'],\n      compression = streamInfo['compression'],\n      useCustomEncoding = encodeFileName !== utf8.utf8encode,\n      encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n      utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n      comment = file.comment,\n      encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n      utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n      useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n      useUTF8ForComment = utfEncodedComment.length !== comment.length,\n      dosTime,\n      dosDate,\n      extraFields = \"\",\n      unicodePathExtraField = \"\",\n      unicodeCommentExtraField = \"\",\n      dir = file.dir,\n      date = file.date;\n  var dataInfo = {\n    crc32: 0,\n    compressedSize: 0,\n    uncompressedSize: 0\n  }; // if the content is streamed, the sizes/crc32 are only available AFTER\n  // the end of the stream.\n\n  if (!streamedContent || streamingEnded) {\n    dataInfo.crc32 = streamInfo['crc32'];\n    dataInfo.compressedSize = streamInfo['compressedSize'];\n    dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n  }\n\n  var bitflag = 0;\n\n  if (streamedContent) {\n    // Bit 3: the sizes/crc32 are set to zero in the local header.\n    // The correct values are put in the data descriptor immediately\n    // following the compressed data.\n    bitflag |= 0x0008;\n  }\n\n  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n    // Bit 11: Language encoding flag (EFS).\n    bitflag |= 0x0800;\n  }\n\n  var extFileAttr = 0;\n  var versionMadeBy = 0;\n\n  if (dir) {\n    // dos or unix, we set the dos dir flag\n    extFileAttr |= 0x00010;\n  }\n\n  if (platform === \"UNIX\") {\n    versionMadeBy = 0x031E; // UNIX, version 3.0\n\n    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n  } else {\n    // DOS or other, fallback to DOS\n    versionMadeBy = 0x0014; // DOS, version 2.0\n\n    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n  } // date\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n\n  dosTime = date.getUTCHours();\n  dosTime = dosTime << 6;\n  dosTime = dosTime | date.getUTCMinutes();\n  dosTime = dosTime << 5;\n  dosTime = dosTime | date.getUTCSeconds() / 2;\n  dosDate = date.getUTCFullYear() - 1980;\n  dosDate = dosDate << 4;\n  dosDate = dosDate | date.getUTCMonth() + 1;\n  dosDate = dosDate << 5;\n  dosDate = dosDate | date.getUTCDate();\n\n  if (useUTF8ForFileName) {\n    // set the unicode path extra field. unzip needs at least one extra\n    // field to correctly handle unicode path, so using the path is as good\n    // as any other information. This could improve the situation with\n    // other archive managers too.\n    // This field is usually used without the utf8 flag, with a non\n    // unicode path in the header (winrar, winzip). This helps (a bit)\n    // with the messy Windows' default compressed folders feature but\n    // breaks on p7zip which doesn't seek the unicode path extra field.\n    // So for now, UTF-8 everywhere !\n    unicodePathExtraField = // Version\n    decToHex(1, 1) + // NameCRC32\n    decToHex(crc32(encodedFileName), 4) + // UnicodeName\n    utfEncodedFileName;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x70\" + // size\n    decToHex(unicodePathExtraField.length, 2) + // content\n    unicodePathExtraField;\n  }\n\n  if (useUTF8ForComment) {\n    unicodeCommentExtraField = // Version\n    decToHex(1, 1) + // CommentCRC32\n    decToHex(crc32(encodedComment), 4) + // UnicodeName\n    utfEncodedComment;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x63\" + // size\n    decToHex(unicodeCommentExtraField.length, 2) + // content\n    unicodeCommentExtraField;\n  }\n\n  var header = \"\"; // version needed to extract\n\n  header += \"\\x0A\\x00\"; // general purpose bit flag\n\n  header += decToHex(bitflag, 2); // compression method\n\n  header += compression.magic; // last mod file time\n\n  header += decToHex(dosTime, 2); // last mod file date\n\n  header += decToHex(dosDate, 2); // crc-32\n\n  header += decToHex(dataInfo.crc32, 4); // compressed size\n\n  header += decToHex(dataInfo.compressedSize, 4); // uncompressed size\n\n  header += decToHex(dataInfo.uncompressedSize, 4); // file name length\n\n  header += decToHex(encodedFileName.length, 2); // extra field length\n\n  header += decToHex(extraFields.length, 2);\n  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n  var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)\n  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)\n  header + // file comment length\n  decToHex(encodedComment.length, 2) + // disk number start\n  \"\\x00\\x00\" + // internal file attributes TODO\n  \"\\x00\\x00\" + // external file attributes\n  decToHex(extFileAttr, 4) + // relative offset of local header\n  decToHex(offset, 4) + // file name\n  encodedFileName + // extra field\n  extraFields + // file comment\n  encodedComment;\n  return {\n    fileRecord: fileRecord,\n    dirRecord: dirRecord\n  };\n};\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */\n\n\nvar generateCentralDirectoryEnd = function generateCentralDirectoryEnd(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n  var dirEnd = \"\";\n  var encodedComment = utils.transformTo(\"string\", encodeFileName(comment)); // end of central dir signature\n\n  dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk\n  \"\\x00\\x00\" + // number of the disk with the start of the central directory\n  \"\\x00\\x00\" + // total number of entries in the central directory on this disk\n  decToHex(entriesCount, 2) + // total number of entries in the central directory\n  decToHex(entriesCount, 2) + // size of the central directory   4 bytes\n  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number\n  decToHex(localDirLength, 4) + // .ZIP file comment length\n  decToHex(encodedComment.length, 2) + // .ZIP file comment\n  encodedComment;\n  return dirEnd;\n};\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing informations\n * on the file entry.\n * @return {String} the data descriptors.\n */\n\n\nvar generateDataDescriptors = function generateDataDescriptors(streamInfo) {\n  var descriptor = \"\";\n  descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes\n  decToHex(streamInfo['crc32'], 4) + // compressed size                 4 bytes\n  decToHex(streamInfo['compressedSize'], 4) + // uncompressed size               4 bytes\n  decToHex(streamInfo['uncompressedSize'], 4);\n  return descriptor;\n};\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */\n\n\nfunction ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n  GenericWorker.call(this, \"ZipFileWorker\"); // The number of bytes written so far. This doesn't count accumulated chunks.\n\n  this.bytesWritten = 0; // The comment of the zip file\n\n  this.zipComment = comment; // The platform \"generating\" the zip file.\n\n  this.zipPlatform = platform; // the function to encode file names and comments.\n\n  this.encodeFileName = encodeFileName; // Should we stream the content of the files ?\n\n  this.streamFiles = streamFiles; // If `streamFiles` is false, we will need to accumulate the content of the\n  // files to calculate sizes / crc32 (and write them *before* the content).\n  // This boolean indicates if we are accumulating chunks (it will change a lot\n  // during the lifetime of this worker).\n\n  this.accumulate = false; // The buffer receiving chunks when accumulating content.\n\n  this.contentBuffer = []; // The list of generated directory records.\n\n  this.dirRecords = []; // The offset (in bytes) from the beginning of the zip file for the current source.\n\n  this.currentSourceOffset = 0; // The total number of entries in this zip file.\n\n  this.entriesCount = 0; // the name of the file currently being added, null when handling the end of the zip file.\n  // Used for the emited metadata.\n\n  this.currentFile = null;\n  this._sources = [];\n}\n\nutils.inherits(ZipFileWorker, GenericWorker);\n/**\n * @see GenericWorker.push\n */\n\nZipFileWorker.prototype.push = function (chunk) {\n  var currentFilePercent = chunk.meta.percent || 0;\n  var entriesCount = this.entriesCount;\n  var remainingFiles = this._sources.length;\n\n  if (this.accumulate) {\n    this.contentBuffer.push(chunk);\n  } else {\n    this.bytesWritten += chunk.data.length;\n    GenericWorker.prototype.push.call(this, {\n      data: chunk.data,\n      meta: {\n        currentFile: this.currentFile,\n        percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n      }\n    });\n  }\n};\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */\n\n\nZipFileWorker.prototype.openedSource = function (streamInfo) {\n  this.currentSourceOffset = this.bytesWritten;\n  this.currentFile = streamInfo['file'].name;\n  var streamedContent = this.streamFiles && !streamInfo['file'].dir; // don't stream folders (because they don't have any content)\n\n  if (streamedContent) {\n    var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n    this.push({\n      data: record.fileRecord,\n      meta: {\n        percent: 0\n      }\n    });\n  } else {\n    // we need to wait for the whole file before pushing anything\n    this.accumulate = true;\n  }\n};\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */\n\n\nZipFileWorker.prototype.closedSource = function (streamInfo) {\n  this.accumulate = false;\n  var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n  var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n  this.dirRecords.push(record.dirRecord);\n\n  if (streamedContent) {\n    // after the streamed file, we put data descriptors\n    this.push({\n      data: generateDataDescriptors(streamInfo),\n      meta: {\n        percent: 100\n      }\n    });\n  } else {\n    // the content wasn't streamed, we need to push everything now\n    // first the file record, then the content\n    this.push({\n      data: record.fileRecord,\n      meta: {\n        percent: 0\n      }\n    });\n\n    while (this.contentBuffer.length) {\n      this.push(this.contentBuffer.shift());\n    }\n  }\n\n  this.currentFile = null;\n};\n/**\n * @see GenericWorker.flush\n */\n\n\nZipFileWorker.prototype.flush = function () {\n  var localDirLength = this.bytesWritten;\n\n  for (var i = 0; i < this.dirRecords.length; i++) {\n    this.push({\n      data: this.dirRecords[i],\n      meta: {\n        percent: 100\n      }\n    });\n  }\n\n  var centralDirLength = this.bytesWritten - localDirLength;\n  var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n  this.push({\n    data: dirEnd,\n    meta: {\n      percent: 100\n    }\n  });\n};\n/**\n * Prepare the next source to be read.\n */\n\n\nZipFileWorker.prototype.prepareNextSource = function () {\n  this.previous = this._sources.shift();\n  this.openedSource(this.previous.streamInfo);\n\n  if (this.isPaused) {\n    this.previous.pause();\n  } else {\n    this.previous.resume();\n  }\n};\n/**\n * @see GenericWorker.registerPrevious\n */\n\n\nZipFileWorker.prototype.registerPrevious = function (previous) {\n  this._sources.push(previous);\n\n  var self = this;\n  previous.on('data', function (chunk) {\n    self.processChunk(chunk);\n  });\n  previous.on('end', function () {\n    self.closedSource(self.previous.streamInfo);\n\n    if (self._sources.length) {\n      self.prepareNextSource();\n    } else {\n      self.end();\n    }\n  });\n  previous.on('error', function (e) {\n    self.error(e);\n  });\n  return this;\n};\n/**\n * @see GenericWorker.resume\n */\n\n\nZipFileWorker.prototype.resume = function () {\n  if (!GenericWorker.prototype.resume.call(this)) {\n    return false;\n  }\n\n  if (!this.previous && this._sources.length) {\n    this.prepareNextSource();\n    return true;\n  }\n\n  if (!this.previous && !this._sources.length && !this.generatedError) {\n    this.end();\n    return true;\n  }\n};\n/**\n * @see GenericWorker.error\n */\n\n\nZipFileWorker.prototype.error = function (e) {\n  var sources = this._sources;\n\n  if (!GenericWorker.prototype.error.call(this, e)) {\n    return false;\n  }\n\n  for (var i = 0; i < sources.length; i++) {\n    try {\n      sources[i].error(e);\n    } catch (e) {// the `error` exploded, nothing to do\n    }\n  }\n\n  return true;\n};\n/**\n * @see GenericWorker.lock\n */\n\n\nZipFileWorker.prototype.lock = function () {\n  GenericWorker.prototype.lock.call(this);\n  var sources = this._sources;\n\n  for (var i = 0; i < sources.length; i++) {\n    sources[i].lock();\n  }\n};\n\nmodule.exports = ZipFileWorker;","map":{"version":3,"sources":["/home/altius/NodeJs/gitHubRepos/fasp-core-ui/node_modules/jszip/lib/generate/ZipFileWorker.js"],"names":["utils","require","GenericWorker","utf8","crc32","signature","decToHex","dec","bytes","hex","i","String","fromCharCode","generateUnixExternalFileAttr","unixPermissions","isDir","result","generateDosExternalFileAttr","dosPermissions","generateZipParts","streamInfo","streamedContent","streamingEnded","offset","platform","encodeFileName","file","compression","useCustomEncoding","utf8encode","encodedFileName","transformTo","name","utfEncodedFileName","comment","encodedComment","utfEncodedComment","useUTF8ForFileName","length","useUTF8ForComment","dosTime","dosDate","extraFields","unicodePathExtraField","unicodeCommentExtraField","dir","date","dataInfo","compressedSize","uncompressedSize","bitflag","extFileAttr","versionMadeBy","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCFullYear","getUTCMonth","getUTCDate","header","magic","fileRecord","LOCAL_FILE_HEADER","dirRecord","CENTRAL_FILE_HEADER","generateCentralDirectoryEnd","entriesCount","centralDirLength","localDirLength","dirEnd","CENTRAL_DIRECTORY_END","generateDataDescriptors","descriptor","DATA_DESCRIPTOR","ZipFileWorker","streamFiles","call","bytesWritten","zipComment","zipPlatform","accumulate","contentBuffer","dirRecords","currentSourceOffset","currentFile","_sources","inherits","prototype","push","chunk","currentFilePercent","meta","percent","remainingFiles","data","openedSource","record","closedSource","shift","flush","prepareNextSource","previous","isPaused","pause","resume","registerPrevious","self","on","processChunk","end","e","error","generatedError","sources","lock","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('../stream/GenericWorker');\nvar utf8 = require('../utf8');\nvar crc32 = require('../crc32');\nvar signature = require('../signature');\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with informations about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */\nvar generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo['file'],\n    compression = streamInfo['compression'],\n    useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment,\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir = file.dir,\n    date = file.date;\n\n\n    var dataInfo = {\n        crc32 : 0,\n        compressedSize : 0,\n        uncompressedSize : 0\n    };\n\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo['crc32'];\n        dataInfo.compressedSize = streamInfo['compressedSize'];\n        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n    }\n\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getUTCMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n        // version made by (00: DOS)\n        decToHex(versionMadeBy, 2) +\n        // file header (common to file and central directory)\n        header +\n        // file comment length\n        decToHex(encodedComment.length, 2) +\n        // disk number start\n        \"\\x00\\x00\" +\n        // internal file attributes TODO\n        \"\\x00\\x00\" +\n        // external file attributes\n        decToHex(extFileAttr, 4) +\n        // relative offset of local header\n        decToHex(offset, 4) +\n        // file name\n        encodedFileName +\n        // extra field\n        extraFields +\n        // file comment\n        encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */\nvar generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(entriesCount, 2) +\n        // total number of entries in the central directory\n        decToHex(entriesCount, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n    return dirEnd;\n};\n\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing informations\n * on the file entry.\n * @return {String} the data descriptors.\n */\nvar generateDataDescriptors = function (streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR +\n        // crc-32                          4 bytes\n        decToHex(streamInfo['crc32'], 4) +\n        // compressed size                 4 bytes\n        decToHex(streamInfo['compressedSize'], 4) +\n        // uncompressed size               4 bytes\n        decToHex(streamInfo['uncompressedSize'], 4);\n\n    return descriptor;\n};\n\n\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */\nfunction ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emited metadata.\n    this.currentFile = null;\n\n\n\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n\n/**\n * @see GenericWorker.push\n */\nZipFileWorker.prototype.push = function (chunk) {\n\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n\n    if(this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n\n        GenericWorker.prototype.push.call(this, {\n            data : chunk.data,\n            meta : {\n                currentFile : this.currentFile,\n                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */\nZipFileWorker.prototype.openedSource = function (streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo['file'].name;\n\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n\n    // don't stream folders (because they don't have any content)\n    if(streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */\nZipFileWorker.prototype.closedSource = function (streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n\n    this.dirRecords.push(record.dirRecord);\n    if(streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data : generateDataDescriptors(streamInfo),\n            meta : {percent:100}\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n        while(this.contentBuffer.length) {\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n\n/**\n * @see GenericWorker.flush\n */\nZipFileWorker.prototype.flush = function () {\n\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++) {\n        this.push({\n            data : this.dirRecords[i],\n            meta : {percent:100}\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n\n    this.push({\n        data : dirEnd,\n        meta : {percent:100}\n    });\n};\n\n/**\n * Prepare the next source to be read.\n */\nZipFileWorker.prototype.prepareNextSource = function () {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n\n/**\n * @see GenericWorker.registerPrevious\n */\nZipFileWorker.prototype.registerPrevious = function (previous) {\n    this._sources.push(previous);\n    var self = this;\n\n    previous.on('data', function (chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n        self.closedSource(self.previous.streamInfo);\n        if(self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on('error', function (e) {\n        self.error(e);\n    });\n    return this;\n};\n\n/**\n * @see GenericWorker.resume\n */\nZipFileWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n\n/**\n * @see GenericWorker.error\n */\nZipFileWorker.prototype.error = function (e) {\n    var sources = this._sources;\n    if(!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++) {\n        try {\n            sources[i].error(e);\n        } catch(e) {\n            // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n\n/**\n * @see GenericWorker.lock\n */\nZipFileWorker.prototype.lock = function () {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++) {\n        sources[i].lock();\n    }\n};\n\nmodule.exports = ZipFileWorker;\n"]},"metadata":{},"sourceType":"script"}