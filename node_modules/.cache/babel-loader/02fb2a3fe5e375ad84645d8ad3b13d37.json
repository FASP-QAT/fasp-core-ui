{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar support = require('./support');\n\nvar nodejsUtils = require('./nodejsUtils');\n\nvar GenericWorker = require('./stream/GenericWorker');\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\n\n\nvar _utf8len = new Array(256);\n\nfor (var i = 0; i < 256; i++) {\n  _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n}\n\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\n\nvar string2buf = function string2buf(str) {\n  var buf,\n      c,\n      c2,\n      m_pos,\n      i,\n      str_len = str.length,\n      buf_len = 0; // count binary size\n\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  } // allocate buffer\n\n\n  if (support.uint8array) {\n    buf = new Uint8Array(buf_len);\n  } else {\n    buf = new Array(buf_len);\n  } // convert\n\n\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n\n  return buf;\n}; // Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\n\n\nvar utf8border = function utf8border(buf, max) {\n  var pos;\n  max = max || buf.length;\n\n  if (max > buf.length) {\n    max = buf.length;\n  } // go back from last position, until start of sequence found\n\n\n  pos = max - 1;\n\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n    pos--;\n  } // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n\n\n  if (pos < 0) {\n    return max;\n  } // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n\n\n  if (pos === 0) {\n    return max;\n  }\n\n  return pos + _utf8len[buf[pos]] > max ? pos : max;\n}; // convert array to string\n\n\nvar buf2string = function buf2string(buf) {\n  var str, i, out, c, c_len;\n  var len = buf.length; // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++]; // quick process ascii\n\n    if (c < 0x80) {\n      utf16buf[out++] = c;\n      continue;\n    }\n\n    c_len = _utf8len[c]; // skip 5 & 6 byte codes\n\n    if (c_len > 4) {\n      utf16buf[out++] = 0xfffd;\n      i += c_len - 1;\n      continue;\n    } // apply mask on first byte\n\n\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest\n\n    while (c_len > 1 && i < len) {\n      c = c << 6 | buf[i++] & 0x3f;\n      c_len--;\n    } // terminated by end of string?\n\n\n    if (c_len > 1) {\n      utf16buf[out++] = 0xfffd;\n      continue;\n    }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n      utf16buf[out++] = 0xdc00 | c & 0x3ff;\n    }\n  } // shrinkBuf(utf16buf, out)\n\n\n  if (utf16buf.length !== out) {\n    if (utf16buf.subarray) {\n      utf16buf = utf16buf.subarray(0, out);\n    } else {\n      utf16buf.length = out;\n    }\n  } // return String.fromCharCode.apply(null, utf16buf);\n\n\n  return utils.applyFromCharCode(utf16buf);\n}; // That's all for the pako functions.\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\n\n\nexports.utf8encode = function utf8encode(str) {\n  if (support.nodebuffer) {\n    return nodejsUtils.newBufferFrom(str, \"utf-8\");\n  }\n\n  return string2buf(str);\n};\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\n\n\nexports.utf8decode = function utf8decode(buf) {\n  if (support.nodebuffer) {\n    return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n  }\n\n  buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n  return buf2string(buf);\n};\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\n\n\nfunction Utf8DecodeWorker() {\n  GenericWorker.call(this, \"utf-8 decode\"); // the last bytes if a chunk didn't end with a complete codepoint.\n\n  this.leftOver = null;\n}\n\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */\n\nUtf8DecodeWorker.prototype.processChunk = function (chunk) {\n  var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data); // 1st step, re-use what's left of the previous chunk\n\n  if (this.leftOver && this.leftOver.length) {\n    if (support.uint8array) {\n      var previousData = data;\n      data = new Uint8Array(previousData.length + this.leftOver.length);\n      data.set(this.leftOver, 0);\n      data.set(previousData, this.leftOver.length);\n    } else {\n      data = this.leftOver.concat(data);\n    }\n\n    this.leftOver = null;\n  }\n\n  var nextBoundary = utf8border(data);\n  var usableData = data;\n\n  if (nextBoundary !== data.length) {\n    if (support.uint8array) {\n      usableData = data.subarray(0, nextBoundary);\n      this.leftOver = data.subarray(nextBoundary, data.length);\n    } else {\n      usableData = data.slice(0, nextBoundary);\n      this.leftOver = data.slice(nextBoundary, data.length);\n    }\n  }\n\n  this.push({\n    data: exports.utf8decode(usableData),\n    meta: chunk.meta\n  });\n};\n/**\n * @see GenericWorker.flush\n */\n\n\nUtf8DecodeWorker.prototype.flush = function () {\n  if (this.leftOver && this.leftOver.length) {\n    this.push({\n      data: exports.utf8decode(this.leftOver),\n      meta: {}\n    });\n    this.leftOver = null;\n  }\n};\n\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\n\nfunction Utf8EncodeWorker() {\n  GenericWorker.call(this, \"utf-8 encode\");\n}\n\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */\n\nUtf8EncodeWorker.prototype.processChunk = function (chunk) {\n  this.push({\n    data: exports.utf8encode(chunk.data),\n    meta: chunk.meta\n  });\n};\n\nexports.Utf8EncodeWorker = Utf8EncodeWorker;","map":{"version":3,"sources":["/home/altius/NodeJs/fasp-core-ui/node_modules/jszip/lib/utf8.js"],"names":["utils","require","support","nodejsUtils","GenericWorker","_utf8len","Array","i","string2buf","str","buf","c","c2","m_pos","str_len","length","buf_len","charCodeAt","uint8array","Uint8Array","utf8border","max","pos","buf2string","out","c_len","len","utf16buf","subarray","applyFromCharCode","exports","utf8encode","nodebuffer","newBufferFrom","utf8decode","transformTo","toString","Utf8DecodeWorker","call","leftOver","inherits","prototype","processChunk","chunk","data","previousData","set","concat","nextBoundary","usableData","slice","push","meta","flush","Utf8EncodeWorker"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodejsUtils = require('./nodejsUtils');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    return buf2string(buf);\n};\n\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\nfunction Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8DecodeWorker.prototype.processChunk = function (chunk) {\n\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if(support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n\n    this.push({\n        data : exports.utf8decode(usableData),\n        meta : chunk.meta\n    });\n};\n\n/**\n * @see GenericWorker.flush\n */\nUtf8DecodeWorker.prototype.flush = function () {\n    if(this.leftOver && this.leftOver.length) {\n        this.push({\n            data : exports.utf8decode(this.leftOver),\n            meta : {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\nfunction Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8EncodeWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : exports.utf8encode(chunk.data),\n        meta : chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n"]},"metadata":{},"sourceType":"script"}