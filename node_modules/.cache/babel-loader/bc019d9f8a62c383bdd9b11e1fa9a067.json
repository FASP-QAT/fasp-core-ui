{"ast":null,"code":"'use strict';\n\nvar readerFor = require('./reader/readerFor');\n\nvar utils = require('./utils');\n\nvar CompressedObject = require('./compressedObject');\n\nvar crc32fn = require('./crc32');\n\nvar utf8 = require('./utf8');\n\nvar compressions = require('./compressions');\n\nvar support = require('./support');\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\n\nvar findCompression = function findCompression(compressionMethod) {\n  for (var method in compressions) {\n    if (!compressions.hasOwnProperty(method)) {\n      continue;\n    }\n\n    if (compressions[method].magic === compressionMethod) {\n      return compressions[method];\n    }\n  }\n\n  return null;\n}; // class ZipEntry {{{\n\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\n\n\nfunction ZipEntry(options, loadOptions) {\n  this.options = options;\n  this.loadOptions = loadOptions;\n}\n\nZipEntry.prototype = {\n  /**\n   * say if the file is encrypted.\n   * @return {boolean} true if the file is encrypted, false otherwise.\n   */\n  isEncrypted: function isEncrypted() {\n    // bit 1 is set\n    return (this.bitFlag & 0x0001) === 0x0001;\n  },\n\n  /**\n   * say if the file has utf-8 filename/comment.\n   * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n   */\n  useUTF8: function useUTF8() {\n    // bit 11 is set\n    return (this.bitFlag & 0x0800) === 0x0800;\n  },\n\n  /**\n   * Read the local part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n  readLocalPart: function readLocalPart(reader) {\n    var compression, localExtraFieldsLength; // we already know everything from the central dir !\n    // If the central dir data are false, we are doomed.\n    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n    // The less data we get here, the more reliable this should be.\n    // Let's skip the whole header and dash to the data !\n\n    reader.skip(22); // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n    // Strangely, the filename here is OK.\n    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n    // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n    // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n    // the internet.\n    //\n    // I think I see the logic here : the central directory is used to display\n    // content and the local directory is used to extract the files. Mixing / and \\\n    // may be used to display \\ to windows users and use / when extracting the files.\n    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n\n    this.fileNameLength = reader.readInt(2);\n    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n    // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n\n    this.fileName = reader.readData(this.fileNameLength);\n    reader.skip(localExtraFieldsLength);\n\n    if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n      throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n    }\n\n    compression = findCompression(this.compressionMethod);\n\n    if (compression === null) {\n      // no compression found\n      throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n    }\n\n    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n  },\n\n  /**\n   * Read the central part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n  readCentralPart: function readCentralPart(reader) {\n    this.versionMadeBy = reader.readInt(2);\n    reader.skip(2); // this.versionNeeded = reader.readInt(2);\n\n    this.bitFlag = reader.readInt(2);\n    this.compressionMethod = reader.readString(2);\n    this.date = reader.readDate();\n    this.crc32 = reader.readInt(4);\n    this.compressedSize = reader.readInt(4);\n    this.uncompressedSize = reader.readInt(4);\n    var fileNameLength = reader.readInt(2);\n    this.extraFieldsLength = reader.readInt(2);\n    this.fileCommentLength = reader.readInt(2);\n    this.diskNumberStart = reader.readInt(2);\n    this.internalFileAttributes = reader.readInt(2);\n    this.externalFileAttributes = reader.readInt(4);\n    this.localHeaderOffset = reader.readInt(4);\n\n    if (this.isEncrypted()) {\n      throw new Error(\"Encrypted zip are not supported\");\n    } // will be read in the local part, see the comments there\n\n\n    reader.skip(fileNameLength);\n    this.readExtraFields(reader);\n    this.parseZIP64ExtraField(reader);\n    this.fileComment = reader.readData(this.fileCommentLength);\n  },\n\n  /**\n   * Parse the external file attributes and get the unix/dos permissions.\n   */\n  processAttributes: function processAttributes() {\n    this.unixPermissions = null;\n    this.dosPermissions = null;\n    var madeBy = this.versionMadeBy >> 8; // Check if we have the DOS directory flag set.\n    // We look for it in the DOS and UNIX permissions\n    // but some unknown platform could set it as a compatibility flag.\n\n    this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n    if (madeBy === MADE_BY_DOS) {\n      // first 6 bits (0 to 5)\n      this.dosPermissions = this.externalFileAttributes & 0x3F;\n    }\n\n    if (madeBy === MADE_BY_UNIX) {\n      this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF; // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n    } // fail safe : if the name ends with a / it probably means a folder\n\n\n    if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n      this.dir = true;\n    }\n  },\n\n  /**\n   * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n   * @param {DataReader} reader the reader to use.\n   */\n  parseZIP64ExtraField: function parseZIP64ExtraField(reader) {\n    if (!this.extraFields[0x0001]) {\n      return;\n    } // should be something, preparing the extra reader\n\n\n    var extraReader = readerFor(this.extraFields[0x0001].value); // I really hope that these 64bits integer can fit in 32 bits integer, because js\n    // won't let us have more.\n\n    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n      this.uncompressedSize = extraReader.readInt(8);\n    }\n\n    if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n      this.compressedSize = extraReader.readInt(8);\n    }\n\n    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n      this.localHeaderOffset = extraReader.readInt(8);\n    }\n\n    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n      this.diskNumberStart = extraReader.readInt(4);\n    }\n  },\n\n  /**\n   * Read the central part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n  readExtraFields: function readExtraFields(reader) {\n    var end = reader.index + this.extraFieldsLength,\n        extraFieldId,\n        extraFieldLength,\n        extraFieldValue;\n\n    if (!this.extraFields) {\n      this.extraFields = {};\n    }\n\n    while (reader.index < end) {\n      extraFieldId = reader.readInt(2);\n      extraFieldLength = reader.readInt(2);\n      extraFieldValue = reader.readData(extraFieldLength);\n      this.extraFields[extraFieldId] = {\n        id: extraFieldId,\n        length: extraFieldLength,\n        value: extraFieldValue\n      };\n    }\n  },\n\n  /**\n   * Apply an UTF8 transformation if needed.\n   */\n  handleUTF8: function handleUTF8() {\n    var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n\n    if (this.useUTF8()) {\n      this.fileNameStr = utf8.utf8decode(this.fileName);\n      this.fileCommentStr = utf8.utf8decode(this.fileComment);\n    } else {\n      var upath = this.findExtraFieldUnicodePath();\n\n      if (upath !== null) {\n        this.fileNameStr = upath;\n      } else {\n        // ASCII text or unsupported code page\n        var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);\n        this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n      }\n\n      var ucomment = this.findExtraFieldUnicodeComment();\n\n      if (ucomment !== null) {\n        this.fileCommentStr = ucomment;\n      } else {\n        // ASCII text or unsupported code page\n        var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);\n        this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n      }\n    }\n  },\n\n  /**\n   * Find the unicode path declared in the extra field, if any.\n   * @return {String} the unicode path, null otherwise.\n   */\n  findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {\n    var upathField = this.extraFields[0x7075];\n\n    if (upathField) {\n      var extraReader = readerFor(upathField.value); // wrong version\n\n      if (extraReader.readInt(1) !== 1) {\n        return null;\n      } // the crc of the filename changed, this field is out of date.\n\n\n      if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n        return null;\n      }\n\n      return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n    }\n\n    return null;\n  },\n\n  /**\n   * Find the unicode comment declared in the extra field, if any.\n   * @return {String} the unicode comment, null otherwise.\n   */\n  findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {\n    var ucommentField = this.extraFields[0x6375];\n\n    if (ucommentField) {\n      var extraReader = readerFor(ucommentField.value); // wrong version\n\n      if (extraReader.readInt(1) !== 1) {\n        return null;\n      } // the crc of the comment changed, this field is out of date.\n\n\n      if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n        return null;\n      }\n\n      return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n    }\n\n    return null;\n  }\n};\nmodule.exports = ZipEntry;","map":{"version":3,"sources":["/home/altius/NodeJs/gitHubRepos/fasp-core-ui/node_modules/jszip/lib/zipEntry.js"],"names":["readerFor","require","utils","CompressedObject","crc32fn","utf8","compressions","support","MADE_BY_DOS","MADE_BY_UNIX","findCompression","compressionMethod","method","hasOwnProperty","magic","ZipEntry","options","loadOptions","prototype","isEncrypted","bitFlag","useUTF8","readLocalPart","reader","compression","localExtraFieldsLength","skip","fileNameLength","readInt","fileName","readData","compressedSize","uncompressedSize","Error","pretty","transformTo","decompressed","crc32","readCentralPart","versionMadeBy","readString","date","readDate","extraFieldsLength","fileCommentLength","diskNumberStart","internalFileAttributes","externalFileAttributes","localHeaderOffset","readExtraFields","parseZIP64ExtraField","fileComment","processAttributes","unixPermissions","dosPermissions","madeBy","dir","fileNameStr","slice","extraFields","extraReader","value","MAX_VALUE_32BITS","end","index","extraFieldId","extraFieldLength","extraFieldValue","id","length","handleUTF8","decodeParamType","uint8array","utf8decode","fileCommentStr","upath","findExtraFieldUnicodePath","fileNameByteArray","decodeFileName","ucomment","findExtraFieldUnicodeComment","commentByteArray","upathField","ucommentField","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar readerFor = require('./reader/readerFor');\nvar utils = require('./utils');\nvar CompressedObject = require('./compressedObject');\nvar crc32fn = require('./crc32');\nvar utf8 = require('./utf8');\nvar compressions = require('./compressions');\nvar support = require('./support');\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nvar findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n\n        while (reader.index < end) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n"]},"metadata":{},"sourceType":"script"}