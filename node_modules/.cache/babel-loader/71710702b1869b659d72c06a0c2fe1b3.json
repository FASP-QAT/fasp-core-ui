{"ast":null,"code":"'use strict';\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */\n\nfunction GenericWorker(name) {\n  // the name of the worker\n  this.name = name || \"default\"; // an object containing metadata about the workers chain\n\n  this.streamInfo = {}; // an error which happened when the worker was paused\n\n  this.generatedError = null; // an object containing metadata to be merged by this worker into the general metadata\n\n  this.extraStreamInfo = {}; // true if the stream is paused (and should not do anything), false otherwise\n\n  this.isPaused = true; // true if the stream is finished (and should not do anything), false otherwise\n\n  this.isFinished = false; // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n\n  this.isLocked = false; // the event listeners\n\n  this._listeners = {\n    'data': [],\n    'end': [],\n    'error': []\n  }; // the previous worker, if any\n\n  this.previous = null;\n}\n\nGenericWorker.prototype = {\n  /**\n   * Push a chunk to the next workers.\n   * @param {Object} chunk the chunk to push\n   */\n  push: function push(chunk) {\n    this.emit(\"data\", chunk);\n  },\n\n  /**\n   * End the stream.\n   * @return {Boolean} true if this call ended the worker, false otherwise.\n   */\n  end: function end() {\n    if (this.isFinished) {\n      return false;\n    }\n\n    this.flush();\n\n    try {\n      this.emit(\"end\");\n      this.cleanUp();\n      this.isFinished = true;\n    } catch (e) {\n      this.emit(\"error\", e);\n    }\n\n    return true;\n  },\n\n  /**\n   * End the stream with an error.\n   * @param {Error} e the error which caused the premature end.\n   * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n   */\n  error: function error(e) {\n    if (this.isFinished) {\n      return false;\n    }\n\n    if (this.isPaused) {\n      this.generatedError = e;\n    } else {\n      this.isFinished = true;\n      this.emit(\"error\", e); // in the workers chain exploded in the middle of the chain,\n      // the error event will go downward but we also need to notify\n      // workers upward that there has been an error.\n\n      if (this.previous) {\n        this.previous.error(e);\n      }\n\n      this.cleanUp();\n    }\n\n    return true;\n  },\n\n  /**\n   * Add a callback on an event.\n   * @param {String} name the name of the event (data, end, error)\n   * @param {Function} listener the function to call when the event is triggered\n   * @return {GenericWorker} the current object for chainability\n   */\n  on: function on(name, listener) {\n    this._listeners[name].push(listener);\n\n    return this;\n  },\n\n  /**\n   * Clean any references when a worker is ending.\n   */\n  cleanUp: function cleanUp() {\n    this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n    this._listeners = [];\n  },\n\n  /**\n   * Trigger an event. This will call registered callback with the provided arg.\n   * @param {String} name the name of the event (data, end, error)\n   * @param {Object} arg the argument to call the callback with.\n   */\n  emit: function emit(name, arg) {\n    if (this._listeners[name]) {\n      for (var i = 0; i < this._listeners[name].length; i++) {\n        this._listeners[name][i].call(this, arg);\n      }\n    }\n  },\n\n  /**\n   * Chain a worker with an other.\n   * @param {Worker} next the worker receiving events from the current one.\n   * @return {worker} the next worker for chainability\n   */\n  pipe: function pipe(next) {\n    return next.registerPrevious(this);\n  },\n\n  /**\n   * Same as `pipe` in the other direction.\n   * Using an API with `pipe(next)` is very easy.\n   * Implementing the API with the point of view of the next one registering\n   * a source is easier, see the ZipFileWorker.\n   * @param {Worker} previous the previous worker, sending events to this one\n   * @return {Worker} the current worker for chainability\n   */\n  registerPrevious: function registerPrevious(previous) {\n    if (this.isLocked) {\n      throw new Error(\"The stream '\" + this + \"' has already been used.\");\n    } // sharing the streamInfo...\n\n\n    this.streamInfo = previous.streamInfo; // ... and adding our own bits\n\n    this.mergeStreamInfo();\n    this.previous = previous;\n    var self = this;\n    previous.on('data', function (chunk) {\n      self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n      self.end();\n    });\n    previous.on('error', function (e) {\n      self.error(e);\n    });\n    return this;\n  },\n\n  /**\n   * Pause the stream so it doesn't send events anymore.\n   * @return {Boolean} true if this call paused the worker, false otherwise.\n   */\n  pause: function pause() {\n    if (this.isPaused || this.isFinished) {\n      return false;\n    }\n\n    this.isPaused = true;\n\n    if (this.previous) {\n      this.previous.pause();\n    }\n\n    return true;\n  },\n\n  /**\n   * Resume a paused stream.\n   * @return {Boolean} true if this call resumed the worker, false otherwise.\n   */\n  resume: function resume() {\n    if (!this.isPaused || this.isFinished) {\n      return false;\n    }\n\n    this.isPaused = false; // if true, the worker tried to resume but failed\n\n    var withError = false;\n\n    if (this.generatedError) {\n      this.error(this.generatedError);\n      withError = true;\n    }\n\n    if (this.previous) {\n      this.previous.resume();\n    }\n\n    return !withError;\n  },\n\n  /**\n   * Flush any remaining bytes as the stream is ending.\n   */\n  flush: function flush() {},\n\n  /**\n   * Process a chunk. This is usually the method overridden.\n   * @param {Object} chunk the chunk to process.\n   */\n  processChunk: function processChunk(chunk) {\n    this.push(chunk);\n  },\n\n  /**\n   * Add a key/value to be added in the workers chain streamInfo once activated.\n   * @param {String} key the key to use\n   * @param {Object} value the associated value\n   * @return {Worker} the current worker for chainability\n   */\n  withStreamInfo: function withStreamInfo(key, value) {\n    this.extraStreamInfo[key] = value;\n    this.mergeStreamInfo();\n    return this;\n  },\n\n  /**\n   * Merge this worker's streamInfo into the chain's streamInfo.\n   */\n  mergeStreamInfo: function mergeStreamInfo() {\n    for (var key in this.extraStreamInfo) {\n      if (!this.extraStreamInfo.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this.streamInfo[key] = this.extraStreamInfo[key];\n    }\n  },\n\n  /**\n   * Lock the stream to prevent further updates on the workers chain.\n   * After calling this method, all calls to pipe will fail.\n   */\n  lock: function lock() {\n    if (this.isLocked) {\n      throw new Error(\"The stream '\" + this + \"' has already been used.\");\n    }\n\n    this.isLocked = true;\n\n    if (this.previous) {\n      this.previous.lock();\n    }\n  },\n\n  /**\n   *\n   * Pretty print the workers chain.\n   */\n  toString: function toString() {\n    var me = \"Worker \" + this.name;\n\n    if (this.previous) {\n      return this.previous + \" -> \" + me;\n    } else {\n      return me;\n    }\n  }\n};\nmodule.exports = GenericWorker;","map":{"version":3,"sources":["/home/altius/NodeJs/fasp-core-ui/node_modules/jszip/lib/stream/GenericWorker.js"],"names":["GenericWorker","name","streamInfo","generatedError","extraStreamInfo","isPaused","isFinished","isLocked","_listeners","previous","prototype","push","chunk","emit","end","flush","cleanUp","e","error","on","listener","arg","i","length","call","pipe","next","registerPrevious","Error","mergeStreamInfo","self","processChunk","pause","resume","withError","withStreamInfo","key","value","hasOwnProperty","lock","toString","me","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */\nfunction GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        'data':[],\n        'end':[],\n        'error':[]\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\n\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */\n    push : function (chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */\n    end : function () {\n        if (this.isFinished) {\n            return false;\n        }\n\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */\n    error : function (e) {\n        if (this.isFinished) {\n            return false;\n        }\n\n        if(this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n\n            this.emit(\"error\", e);\n\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if(this.previous) {\n                this.previous.error(e);\n            }\n\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */\n    on : function (name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */\n    cleanUp : function () {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */\n    emit : function (name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++) {\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */\n    pipe : function (next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */\n    registerPrevious : function (previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous =  previous;\n        var self = this;\n        previous.on('data', function (chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on('end', function () {\n            self.end();\n        });\n        previous.on('error', function (e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */\n    pause : function () {\n        if(this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n\n        if(this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */\n    resume : function () {\n        if(!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if(this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if(this.previous) {\n            this.previous.resume();\n        }\n\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */\n    flush : function () {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */\n    processChunk : function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */\n    withStreamInfo : function (key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */\n    mergeStreamInfo : function () {\n        for(var key in this.extraStreamInfo) {\n            if (!this.extraStreamInfo.hasOwnProperty(key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */\n    lock: function () {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n\n    /**\n     *\n     * Pretty print the workers chain.\n     */\n    toString : function () {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\n\nmodule.exports = GenericWorker;\n"]},"metadata":{},"sourceType":"script"}