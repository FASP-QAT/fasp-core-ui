{"ast":null,"code":"import _possibleConstructorReturn from \"/home/altius/Documents/QAT/fasp-core-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/altius/Documents/QAT/fasp-core-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"/home/altius/Documents/QAT/fasp-core-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/altius/Documents/QAT/fasp-core-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/home/altius/Documents/QAT/fasp-core-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/altius/Documents/QAT/fasp-core-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport React from 'react';\nimport { propsEqual } from 'react-shallow-equal';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar defaultArray = [];\nvar emptyString = '';\n\nfunction adjustCaretPosition(_ref) {\n  var _ref$previousConforme = _ref.previousConformedValue,\n      previousConformedValue = _ref$previousConforme === void 0 ? emptyString : _ref$previousConforme,\n      _ref$previousPlacehol = _ref.previousPlaceholder,\n      previousPlaceholder = _ref$previousPlacehol === void 0 ? emptyString : _ref$previousPlacehol,\n      _ref$currentCaretPosi = _ref.currentCaretPosition,\n      currentCaretPosition = _ref$currentCaretPosi === void 0 ? 0 : _ref$currentCaretPosi,\n      conformedValue = _ref.conformedValue,\n      rawValue = _ref.rawValue,\n      placeholderChar = _ref.placeholderChar,\n      placeholder = _ref.placeholder,\n      _ref$indexesOfPipedCh = _ref.indexesOfPipedChars,\n      indexesOfPipedChars = _ref$indexesOfPipedCh === void 0 ? defaultArray : _ref$indexesOfPipedCh,\n      _ref$caretTrapIndexes = _ref.caretTrapIndexes,\n      caretTrapIndexes = _ref$caretTrapIndexes === void 0 ? defaultArray : _ref$caretTrapIndexes;\n\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  } // Store lengths for faster performance?\n\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var conformedValueLength = conformedValue.length; // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n\n  var editLength = rawValueLength - previousConformedValueLength; // If the edit length is positive, that means the user is adding characters, not deleting.\n\n  var isAddition = editLength > 0; // This is the first raw value the user entered that needs to be conformed to mask\n\n  var isFirstRawValue = previousConformedValueLength === 0; // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n\n  var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue; // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  } // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n\n\n  var possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n  var startingSearchIndex = 0;\n  var trackRightCharacter;\n  var targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    var normalizedConformedValue = conformedValue.toLowerCase();\n    var normalizedRawValue = rawValue.toLowerCase(); // Then we take all characters that come before where the caret currently is.\n\n    var leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString); // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n\n    var intersection = leftHalfChars.filter(function (char) {\n      return normalizedConformedValue.indexOf(char) !== -1;\n    }); // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n\n    targetChar = intersection[intersection.length - 1]; // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n\n    var previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return char !== placeholderChar;\n    }).length; // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n\n    var leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return char !== placeholderChar;\n    }).length; // Has the number of mask characters up to the caret changed?\n\n    var masklengthChanged = leftMaskChars !== previousLeftMaskChars; // Detect if `targetChar` is a mask character and has moved to the left\n\n    var targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]; // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n\n    if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    } // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n\n\n    var pipedChars = indexesOfPipedChars.map(function (index) {\n      return normalizedConformedValue[index];\n    }); // We need to know how many times the `targetChar` occurs in the piped characters.\n\n    var countTargetCharInPipedChars = pipedChars.filter(function (char) {\n      return char === targetChar;\n    }).length; // We need to know how many times it occurs in the intersection\n\n    var countTargetCharInIntersection = intersection.filter(function (char) {\n      return char === targetChar;\n    }).length; // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n\n    var countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter(function (char, index) {\n      return (// Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar && // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      );\n    }).length; // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n\n    var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + ( // The character to the right of the caret isn't included in `intersection`\n    // so add one if we are tracking the character to the right\n    trackRightCharacter ? 1 : 0); // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n\n    var numberOfEncounteredMatches = 0;\n\n    for (var i = 0; i < conformedValueLength; i++) {\n      var conformedValueChar = normalizedConformedValue[i];\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  } // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n  // In case of addition, we fast forward.\n\n\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    var lastPlaceholderChar = startingSearchIndex;\n\n    for (var _i = startingSearchIndex; _i <= placeholderLength; _i++) {\n      if (placeholder[_i] === placeholderChar) {\n        lastPlaceholderChar = _i;\n      }\n\n      if ( // If we're adding, we can position the caret at the next placeholder character.\n      placeholder[_i] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n      caretTrapIndexes.indexOf(_i) !== -1 || // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n      _i === placeholderLength) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (var _i2 = startingSearchIndex - 1; _i2 >= 0; _i2--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n        if ( // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n        // to the right of the caret\n        conformedValue[_i2] === targetChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(_i2) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        _i2 === 0) {\n          return _i2;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n      for (var _i3 = startingSearchIndex; _i3 >= 0; _i3--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n        if ( // If we're deleting, we can position the caret right before the placeholder character\n        placeholder[_i3 - 1] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(_i3) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        _i3 === 0) {\n          return _i3;\n        }\n      }\n    }\n  }\n}\n\nvar placeholderChar = '_';\nvar strFunction = 'function';\nvar emptyArray = [];\n\nfunction convertMaskToPlaceholder() {\n  var mask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyArray;\n  var placeholderChar$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeholderChar;\n\n  if (!isArray(mask)) {\n    throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n  }\n\n  if (mask.indexOf(placeholderChar$$1) !== -1) {\n    throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + \"The placeholder character that was received is: \".concat(JSON.stringify(placeholderChar$$1), \"\\n\\n\") + \"The mask that was received is: \".concat(JSON.stringify(mask)));\n  }\n\n  return mask.map(function (char) {\n    return char instanceof RegExp ? placeholderChar$$1 : char;\n  }).join('');\n}\n\nfunction isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' && value.length === undefined && !isNaN(value);\n}\n\nvar strCaretTrap = '[]';\n\nfunction processCaretTraps(mask) {\n  var indexes = [];\n  var indexOfCaretTrap;\n\n  while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n    // eslint-disable-line\n    indexes.push(indexOfCaretTrap);\n    mask.splice(indexOfCaretTrap, 1);\n  }\n\n  return {\n    maskWithoutCaretTraps: mask,\n    indexes: indexes\n  };\n}\n\nvar emptyArray$1 = [];\nvar emptyString$1 = '';\n\nfunction conformToMask() {\n  var rawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyString$1;\n  var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyArray$1;\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === strFunction) {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config$guide = config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? emptyString$1 : _config$previousConfo,\n      _config$placeholderCh = config.placeholderChar,\n      placeholderChar$$1 = _config$placeholderCh === void 0 ? placeholderChar : _config$placeholderCh,\n      _config$placeholder = config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar$$1) : _config$placeholder,\n      currentCaretPosition = config.currentCaretPosition,\n      keepCharPositions = config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = emptyString$1; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar$$1) {\n        compensatingPlaceholderChars += placeholderChar$$1;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split(emptyString$1).map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i4 = rawValueLength - 1; _i4 >= 0; _i4--) {\n    var char = rawValueArr[_i4].char;\n\n    if (char !== placeholderChar$$1) {\n      var shouldOffset = _i4 >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i4 - editDistance : _i4]) {\n        rawValueArr.splice(_i4, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = emptyString$1;\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i5 = 0; _i5 < placeholderLength; _i5++) {\n    var charInPlaceholder = placeholder[_i5]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar$$1) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          var _rawValueArr$shift = rawValueArr.shift(),\n              rawValueChar = _rawValueArr$shift.char,\n              isNew = _rawValueArr$shift.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar$$1 && suppressGuide !== true) {\n            conformedValue += placeholderChar$$1; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i5].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString$1 || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i6 = 0; _i6 < rawValueArrLength; _i6++) {\n                var charData = rawValueArr[_i6];\n\n                if (charData.char !== placeholderChar$$1 && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar$$1) {\n                  indexOfNextAvailablePlaceholderChar = _i6;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i5--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i5, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i7 = 0; _i7 < conformedValue.length; _i7++) {\n      if (placeholder[_i7] === placeholderChar$$1) {\n        indexOfLastFilledPlaceholderChar = _i7;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString$1;\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (inputValue == null) return '';\n  if (isString(inputValue)) return inputValue;\n  if (isNumber(inputValue)) return String(inputValue);\n  throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \" + \"received was:\\n\\n \".concat(JSON.stringify(inputValue)));\n}\n\nvar TextMaskTransformer = /*#__PURE__*/function () {\n  function TextMaskTransformer() {\n    _classCallCheck(this, TextMaskTransformer);\n\n    this.previousConformedValue = undefined;\n    this.previousPlaceholder = undefined;\n  }\n\n  _createClass(TextMaskTransformer, [{\n    key: \"update\",\n    value: function update(_ref2) {\n      var rawValue = _ref2.value,\n          currentCaretPosition = _ref2.caretPosition,\n          providedMask = _ref2.mask,\n          guide = _ref2.guide,\n          pipe = _ref2.pipe,\n          _ref2$placeholderChar = _ref2.placeholderChar,\n          placeholderChar$$1 = _ref2$placeholderChar === void 0 ? placeholderChar : _ref2$placeholderChar,\n          _ref2$keepCharPositio = _ref2.keepCharPositions,\n          keepCharPositions = _ref2$keepCharPositio === void 0 ? false : _ref2$keepCharPositio,\n          _ref2$showMask = _ref2.showMask,\n          showMask = _ref2$showMask === void 0 ? false : _ref2$showMask;\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === this.previousConformedValue) {\n        return null;\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together.\n      // If such a `mask` is passed, we destructure it below, so the rest of the code can work normally\n      // as if a separate `mask` and a `pipe` were passed.\n\n\n      if (providedMask != null && typeof providedMask === 'object' && providedMask.pipe != null && providedMask.mask != null) {\n        /* eslint-disable no-param-reassign, prefer-destructuring */\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n        /* eslint-enable */\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`,\n      // the placeholder would be `(___)` if the `placeholderChar` is set to `_`.\n\n\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function,\n      // we will have to call that function to get the mask array.\n\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n\n      if (Array.isArray(providedMask)) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar$$1);\n      } // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n\n\n      var safeRawValue = getSafeRawValue(rawValue); // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n\n      if (providedMask === false) {\n        return {\n          value: safeRawValue,\n          caretPosition: currentCaretPosition\n        };\n      }\n\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: this.previousConformedValue,\n          placeholderChar: placeholderChar$$1\n        }); // disable masking if `mask` is `false`\n\n        if (mask === false) {\n          return null;\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n\n\n        var _processCaretTraps = processCaretTraps(mask),\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n            indexes = _processCaretTraps.indexes; // The processed mask is what we're interested in\n\n\n        mask = maskWithoutCaretTraps; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        caretTrapIndexes = indexes;\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar$$1); // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n\n\n      var conformToMaskConfig = {\n        previousConformedValue: this.previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar$$1,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\n\n\n      var piped = typeof pipe === 'function';\n      var pipeResults = {}; // If `pipe` is a function, we call it.\n\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just\n        // return `false` to indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,\n          // and set `rejected` to `true`.\n          pipeResults = {\n            value: this.previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n\n\n      var finalConformedValue = piped ? pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: this.previousConformedValue,\n        previousPlaceholder: this.previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar$$1,\n        indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : '';\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      this.previousConformedValue = inputElementValue; // store value for access for next time\n\n      this.previousPlaceholder = placeholder;\n      return {\n        value: inputElementValue,\n        caretPosition: adjustedCaretPosition\n      };\n    }\n  }]);\n\n  return TextMaskTransformer;\n}();\n\nvar TextMask = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(TextMask, _React$PureComponent);\n\n  function TextMask(props, context) {\n    var _this;\n\n    _classCallCheck(this, TextMask);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextMask).call(this, props, context));\n    _this._update = _this._update.bind(_assertThisInitialized(_this));\n    _this._getRef = _this._getRef.bind(_assertThisInitialized(_this));\n    _this._onChange = _this._onChange.bind(_assertThisInitialized(_this));\n    _this.component = null;\n    _this.textMaskTransformer = new TextMaskTransformer();\n    var value = props.value != null ? props.value : '';\n\n    var nextUpdate = _this._update(_extends({}, props, {\n      value: value\n    }));\n\n    if (nextUpdate !== null) {\n      _this.state = {\n        value: nextUpdate.value,\n        caretPosition: nextUpdate.caretPosition\n      };\n    } else {\n      _this.state = {\n        value: '',\n        caretPosition: 0\n      };\n    }\n\n    return _this;\n  }\n\n  _createClass(TextMask, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var ignore = [];\n\n      if (nextProps.isControlled === false) {\n        ignore.push('value');\n      }\n\n      if (!propsEqual(this.props, nextProps, {\n        ignore: ignore\n      })) {\n        var value = nextProps.isControlled === true && nextProps.value != null ? nextProps.value : this.state.value;\n\n        var nextUpdate = this._update(_extends({}, nextProps, {\n          value: value\n        }));\n\n        if (nextUpdate !== null) {\n          this.setState(nextUpdate);\n        }\n      }\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(props) {\n      return this.textMaskTransformer.update({\n        value: props.value,\n        caretPosition: this.component != null ? this.component.caretPosition : 0,\n        mask: props.mask,\n        guide: props.guide,\n        pipe: props.pipe,\n        placeholderChar: props.placeholderChar,\n        keepCharPositions: props.keepCharPositions,\n        showMask: props.showMask\n      });\n    }\n  }, {\n    key: \"_getRef\",\n    value: function _getRef(comp) {\n      if (comp) {\n        this.props.componentRef(comp);\n        this.component = comp;\n      }\n    }\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(event) {\n      var _this2 = this;\n\n      if (event) {\n        var rawValue = typeof event.target === 'object' ? event.target.value : event.text;\n\n        var nextUpdate = this._update(_extends({}, this.props, {\n          value: rawValue\n        }));\n\n        if (nextUpdate !== null) {\n          this.setState(nextUpdate, function () {\n            _this2.props.onChange(event, nextUpdate);\n          });\n        } else {\n          this.props.onChange(event, this.state);\n          this.forceUpdate();\n        }\n      }\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (this.component.input) this.component.input.focus();\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      if (this.component.input) this.component.input.blur();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          Component = _this$props.Component,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"Component\", \"value\", \"isControlled\", \"mask\", \"guide\", \"pipe\", \"placeholderChar\", \"keepCharPositions\", \"showMask\", \"componentRef\", \"onChange\"]);\n\n      return React.createElement(Component, _extends({}, rest, {\n        value: this.state.value,\n        caretPosition: this.state.caretPosition,\n        onChange: this._onChange,\n        ref: this._getRef\n      }));\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.state.value;\n    }\n  }]);\n\n  return TextMask;\n}(React.PureComponent);\n\nTextMask.defaultProps = {\n  value: null,\n  isControlled: true,\n  guide: true,\n  pipe: null,\n  placeholderChar: '_',\n  keepCharPositions: false,\n  showMask: false,\n  onChange: function onChange() {},\n  componentRef: function componentRef() {}\n};\nvar isAndroid = typeof navigator !== 'undefined' && navigator !== null && /android/i.test(navigator.userAgent);\nvar isDocument = typeof document !== 'undefined' && document !== null;\n\nvar InputAdapter = /*#__PURE__*/function (_React$PureComponent2) {\n  _inherits(InputAdapter, _React$PureComponent2);\n\n  function InputAdapter(props) {\n    var _this3;\n\n    _classCallCheck(this, InputAdapter);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(InputAdapter).call(this, props));\n    _this3._getRef = _this3._getRef.bind(_assertThisInitialized(_this3));\n    _this3._onChange = _this3._onChange.bind(_assertThisInitialized(_this3));\n    return _this3;\n  }\n\n  _createClass(InputAdapter, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._setCaretPosition();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this._setCaretPosition();\n    }\n  }, {\n    key: \"_getRef\",\n    value: function _getRef(ref) {\n      this.input = ref;\n    }\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(event) {\n      event.persist();\n      this.props.onChange(event);\n    }\n  }, {\n    key: \"_setCaretPosition\",\n    value: function _setCaretPosition() {\n      var _this4 = this;\n\n      if (isDocument && this.input === document.activeElement) {\n        if (isAndroid === true) {\n          setTimeout(function () {\n            _this4.input.setSelectionRange(_this4.props.caretPosition, _this4.props.caretPosition, 'none');\n          }, 0);\n        } else {\n          this.input.setSelectionRange(this.props.caretPosition, this.props.caretPosition, 'none');\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"caretPosition\", \"onChange\"]);\n\n      return React.createElement(\"input\", _extends({\n        ref: this._getRef,\n        type: \"text\",\n        onChange: this._onChange\n      }, rest));\n    }\n  }, {\n    key: \"caretPosition\",\n    get: function get() {\n      return this.input.selectionEnd;\n    }\n  }]);\n\n  return InputAdapter;\n}(React.PureComponent);\n\nvar SpanAdapter = /*#__PURE__*/function (_React$PureComponent3) {\n  _inherits(SpanAdapter, _React$PureComponent3);\n\n  function SpanAdapter() {\n    _classCallCheck(this, SpanAdapter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SpanAdapter).apply(this, arguments));\n  }\n\n  _createClass(SpanAdapter, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          value = _this$props.value,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"value\", \"caretPosition\", \"onChange\"]);\n\n      return React.createElement(\"span\", rest, value);\n    }\n  }, {\n    key: \"caretPosition\",\n    // eslint-disable-next-line class-methods-use-this\n    get: function get() {\n      return 0;\n    }\n  }]);\n\n  return SpanAdapter;\n}(React.PureComponent);\n\nexport { TextMask, InputAdapter, SpanAdapter, TextMaskTransformer };","map":{"version":3,"sources":["../node_modules/text-mask-core/src/adjustCaretPosition.js","../node_modules/text-mask-core/src/constants.js","../node_modules/text-mask-core/src/utilities.js","../node_modules/text-mask-core/src/conformToMask.js","../src/TextMaskTransformer.js","../src/TextMask.js","../src/InputAdapter.js","../src/SpanAdapter.js"],"names":["defaultArray","emptyString","previousConformedValue","previousPlaceholder","currentCaretPosition","indexesOfPipedChars","caretTrapIndexes","rawValue","rawValueLength","previousConformedValueLength","placeholderLength","placeholder","conformedValueLength","conformedValue","editLength","isAddition","isFirstRawValue","isPartialMultiCharEdit","possiblyHasRejectedChar","startingSearchIndex","normalizedConformedValue","normalizedRawValue","leftHalfChars","intersection","char","targetChar","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","trackRightCharacter","pipedChars","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","i","conformedValueChar","lastPlaceholderChar","placeholderChar","strFunction","emptyArray","mask","isArray","JSON","Array","value","isNaN","strCaretTrap","indexes","indexOfCaretTrap","maskWithoutCaretTraps","config","processCaretTraps","guide","convertMaskToPlaceholder","keepCharPositions","suppressGuide","maskLength","editDistance","indexOfFirstChange","indexOfLastChange","Math","compensatingPlaceholderChars","rawValueArr","isNew","shouldOffset","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","indexOfLastFilledPlaceholderChar","meta","inputValue","isString","isNumber","String","constructor","caretPosition","showMask","providedMask","pipe","safeRawValue","getSafeRawValue","conformToMaskConfig","conformToMask","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","adjustCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","React","props","nextUpdate","ignore","nextProps","propsEqual","event","Component","_getRef","TextMask","isControlled","onChange","componentRef","isAndroid","navigator","isDocument","document","setTimeout","rest","_onChange"],"mappings":"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","sourcesContent":["const defaultArray = []\nconst emptyString = ''\n\nexport default function adjustCaretPosition({\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = defaultArray,\n  caretTrapIndexes = defaultArray\n}) {\n  if (currentCaretPosition === 0 || !rawValue.length) { return 0 }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const conformedValueLength = conformedValue.length\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) { return currentCaretPosition }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar = isAddition && (\n    previousConformedValue === conformedValue ||\n    conformedValue === placeholder\n  )\n\n  let startingSearchIndex = 0\n  let trackRightCharacter\n  let targetChar\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase()\n    const normalizedRawValue = rawValue.toLowerCase()\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString)\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter((char) => normalizedConformedValue.indexOf(char) !== -1)\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1]\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft = (\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]\n    )\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true\n      targetChar = rawValue[currentCaretPosition]\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map((index) => normalizedConformedValue[index])\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter((char) => char === targetChar).length\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter((char) => char === targetChar).length\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split(emptyString)\n      .filter((char, index) => (\n        // Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar &&\n\n        // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      ))\n      .length\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches = (\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0)\n    )\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i]\n\n      startingSearchIndex = i + 1\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    }\n  }\n}\n","export const placeholderChar = '_'\nexport const strFunction = 'function'\n","import {placeholderChar as defaultPlaceholderChar} from './constants'\n\nconst emptyArray = []\n\nexport function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = defaultPlaceholderChar) {\n  if (!isArray(mask)) {\n    throw new Error(\n      'Text-mask:convertMaskToPlaceholder; The mask property must be an array.'\n    )\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n      'that is not present in your mask as your placeholder character.\\n\\n' +\n      `The placeholder character that was received is: ${JSON.stringify(placeholderChar)}\\n\\n` +\n      `The mask that was received is: ${JSON.stringify(mask)}`\n    )\n  }\n\n  return mask.map((char) => {\n    return (char instanceof RegExp) ? placeholderChar : char\n  }).join('')\n}\n\nexport function isArray(value) {\n  return (Array.isArray && Array.isArray(value)) || value instanceof Array\n}\n\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number' && value.length === undefined && !isNaN(value)\n}\n\nexport function isNil(value) {\n  return typeof value === 'undefined' || value === null\n}\n\nconst strCaretTrap = '[]'\nexport function processCaretTraps(mask) {\n  const indexes = []\n\n  let indexOfCaretTrap\n  while(indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) { // eslint-disable-line\n    indexes.push(indexOfCaretTrap)\n\n    mask.splice(indexOfCaretTrap, 1)\n  }\n\n  return {maskWithoutCaretTraps: mask, indexes}\n}\n","import {convertMaskToPlaceholder, isArray, processCaretTraps} from './utilities'\nimport {placeholderChar as defaultPlaceholderChar, strFunction} from './constants'\n\nconst emptyArray = []\nconst emptyString = ''\n\nexport default function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === strFunction) {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config)\n\n      // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n      mask = processCaretTraps(mask).maskWithoutCaretTraps\n    } else {\n      throw new Error(\n        'Text-mask:conformToMask; The mask property must be an array.'\n      )\n    }\n  }\n\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = emptyString,\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions\n  } = config\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const maskLength = mask.length\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0)\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance)\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = emptyString\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue = (\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength)\n    )\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue\n    .split(emptyString)\n    .map((char, i) => ({char, isNew: i >= indexOfFirstChange && i < indexOfLastChange}))\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const {char} = rawValueArr[i]\n\n    if (char !== placeholderChar) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength\n\n      if (char === placeholder[(shouldOffset) ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1)\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString\n  let someCharsRejected = false\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i]\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const {char: rawValueChar, isNew} = rawValueArr.shift()\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop\n\n          // Else if, the character we got from the user input is not a placeholder, let's see\n          // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              isNew === false ||\n              previousConformedValue === emptyString ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += rawValueChar\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length\n              let indexOfNextAvailablePlaceholderChar = null\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let i = 0; i < rawValueArrLength; i++) {\n                const charData = rawValueArr[i]\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = i\n                  break\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1)\n\n              // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n              // discard it.\n              } else {\n                i--\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop\n          } else {\n            someCharsRejected = true\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength)\n      }\n\n      // And we break\n      break\n\n    // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n    // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1)\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString\n    }\n  }\n\n  return {conformedValue, meta: {someCharsRejected}}\n}\n","import adjustCaretPosition from 'text-mask-core/src/adjustCaretPosition';\nimport conformToMask from 'text-mask-core/src/conformToMask';\nimport {convertMaskToPlaceholder, isString, isNumber, processCaretTraps} from 'text-mask-core/src/utilities';\nimport {placeholderChar as defaultPlaceholderChar} from 'text-mask-core/src/constants';\n\nfunction getSafeRawValue(inputValue) {\n    if (inputValue == null) return '';\n    if (isString(inputValue)) return inputValue;\n    if (isNumber(inputValue)) return String(inputValue);\n\n    throw new Error(\n        \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\n            `received was:\\n\\n ${JSON.stringify(inputValue)}`\n    );\n}\n\nexport default class TextMaskTransformer {\n    constructor() {\n        this.previousConformedValue = undefined;\n        this.previousPlaceholder = undefined;\n    }\n\n    update({\n        value: rawValue,\n        caretPosition: currentCaretPosition,\n        mask: providedMask,\n        guide,\n        pipe,\n        placeholderChar = defaultPlaceholderChar,\n        keepCharPositions = false,\n        showMask = false,\n    }) {\n        // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n        // This check is here to handle controlled framework components that repeat the `update` call on every render.\n        if (rawValue === this.previousConformedValue) {\n            return null;\n        }\n\n        // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together.\n        // If such a `mask` is passed, we destructure it below, so the rest of the code can work normally\n        // as if a separate `mask` and a `pipe` were passed.\n        if (\n            providedMask != null &&\n            typeof providedMask === 'object' &&\n            providedMask.pipe != null &&\n            providedMask.mask != null\n        ) {\n            /* eslint-disable no-param-reassign, prefer-destructuring */\n            pipe = providedMask.pipe;\n            providedMask = providedMask.mask;\n            /* eslint-enable */\n        }\n\n        // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`,\n        // the placeholder would be `(___)` if the `placeholderChar` is set to `_`.\n        let placeholder;\n\n        // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function,\n        // we will have to call that function to get the mask array.\n        let mask;\n\n        // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n        // correct `placeholder`.\n        if (Array.isArray(providedMask)) {\n            placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n        }\n\n        // We check the provided `rawValue` before moving further.\n        // If it's something we can't work with `getSafeRawValue` will throw.\n        const safeRawValue = getSafeRawValue(rawValue);\n\n        // In framework components that support reactivity, it's possible to turn off masking by passing\n        // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n        if (providedMask === false) {\n            return {\n                value: safeRawValue,\n                caretPosition: currentCaretPosition,\n            };\n        }\n\n        let caretTrapIndexes;\n\n        // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n        // Then we also need to get the `placeholder`\n        if (typeof providedMask === 'function') {\n            mask = providedMask(safeRawValue, {\n                currentCaretPosition,\n                previousConformedValue: this.previousConformedValue,\n                placeholderChar,\n            });\n\n            // disable masking if `mask` is `false`\n            if (mask === false) {\n                return null;\n            }\n\n            // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n            // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n            // the indexes of the caret traps.\n            const {maskWithoutCaretTraps, indexes} = processCaretTraps(mask);\n\n            // The processed mask is what we're interested in\n            mask = maskWithoutCaretTraps;\n            // And we need to store these indexes because they're needed by `adjustCaretPosition`\n            caretTrapIndexes = indexes;\n\n            placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n            // If the `providedMask` is not a function, we just use it as-is.\n        } else {\n            mask = providedMask;\n        }\n\n        // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n        const conformToMaskConfig = {\n            previousConformedValue: this.previousConformedValue,\n            guide,\n            placeholderChar,\n            pipe,\n            placeholder,\n            currentCaretPosition,\n            keepCharPositions,\n        };\n\n        // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n        const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n\n        // The following few lines are to support the `pipe` feature.\n        const piped = typeof pipe === 'function';\n\n        let pipeResults = {};\n\n        // If `pipe` is a function, we call it.\n        if (piped) {\n            // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n            pipeResults = pipe(\n                conformedValue,\n                {rawValue: safeRawValue, ...conformToMaskConfig}\n            );\n\n            // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just\n            // return `false` to indicate rejection. Or return just a string when there are no piped characters.\n            // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n            // of the code can work with.\n            if (pipeResults === false) {\n                // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,\n                // and set `rejected` to `true`.\n                pipeResults = {value: this.previousConformedValue, rejected: true};\n            } else if (isString(pipeResults)) {\n                pipeResults = {value: pipeResults};\n            }\n        }\n\n        // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n        // returned by `conformToMask`.\n        const finalConformedValue = piped ? pipeResults.value : conformedValue;\n\n        // After determining the conformed value, we will need to know where to set\n        // the caret position. `adjustCaretPosition` will tell us.\n        const adjustedCaretPosition = adjustCaretPosition({\n            previousConformedValue: this.previousConformedValue,\n            previousPlaceholder: this.previousPlaceholder,\n            conformedValue: finalConformedValue,\n            placeholder,\n            rawValue: safeRawValue,\n            currentCaretPosition,\n            placeholderChar,\n            indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n            caretTrapIndexes,\n        });\n\n        // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n        const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n        const emptyValue = showMask ? placeholder : '';\n        const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n\n        this.previousConformedValue = inputElementValue; // store value for access for next time\n        this.previousPlaceholder = placeholder;\n\n        return {\n            value: inputElementValue,\n            caretPosition: adjustedCaretPosition,\n        };\n    }\n}\n","import React from 'react';\nimport {propsEqual} from 'react-shallow-equal';\nimport TextMaskTransformer from './TextMaskTransformer';\n\nexport default class TextMask extends React.PureComponent {\n    constructor(props, context) {\n        super(props, context);\n        this._update = this._update.bind(this);\n        this._getRef = this._getRef.bind(this);\n        this._onChange = this._onChange.bind(this);\n\n        this.component = null;\n        this.textMaskTransformer = new TextMaskTransformer();\n\n        const value = props.value != null ? props.value : '';\n        const nextUpdate = this._update({...props, value});\n\n        if (nextUpdate !== null) {\n            this.state = {\n                value: nextUpdate.value,\n                caretPosition: nextUpdate.caretPosition,\n            };\n        } else {\n            this.state = {\n                value: '',\n                caretPosition: 0,\n            };\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        const ignore = [];\n\n        if (nextProps.isControlled === false) {\n            ignore.push('value');\n        }\n\n        if (!propsEqual(this.props, nextProps, {ignore})) {\n            const value =\n                nextProps.isControlled === true && nextProps.value != null ? nextProps.value : this.state.value;\n            const nextUpdate = this._update({...nextProps, value});\n            if (nextUpdate !== null) {\n                this.setState(nextUpdate);\n            }\n        }\n    }\n\n    get value() {\n        return this.state.value;\n    }\n\n    _update(props) {\n        return this.textMaskTransformer.update({\n            value: props.value,\n            caretPosition: this.component != null ? this.component.caretPosition : 0,\n            mask: props.mask,\n            guide: props.guide,\n            pipe: props.pipe,\n            placeholderChar: props.placeholderChar,\n            keepCharPositions: props.keepCharPositions,\n            showMask: props.showMask,\n        });\n    }\n\n    _getRef(comp) {\n        if (comp) {\n            this.props.componentRef(comp);\n            this.component = comp;\n        }\n    }\n\n    _onChange(event) {\n        if (event) {\n            const rawValue = typeof event.target === 'object' ? event.target.value : event.text;\n            const nextUpdate = this._update({...this.props, value: rawValue});\n\n            if (nextUpdate !== null) {\n                this.setState(nextUpdate, () => {\n                    this.props.onChange(event, nextUpdate);\n                });\n            } else {\n                this.props.onChange(event, this.state);\n                this.forceUpdate();\n            }\n        }\n    }\n\n    focus() {\n        if (this.component.input) this.component.input.focus();\n    }\n\n    blur() {\n        if (this.component.input) this.component.input.blur();\n    }\n\n    render() {\n        const {\n            Component,\n            value,\n            isControlled,\n            mask,\n            guide,\n            pipe,\n            placeholderChar,\n            keepCharPositions,\n            showMask,\n            componentRef,\n            onChange,\n            ...rest\n        } = this.props;\n\n        return (\n            <Component\n                {...rest}\n                value={this.state.value}\n                caretPosition={this.state.caretPosition}\n                onChange={this._onChange}\n                ref={this._getRef}\n            />\n        );\n    }\n}\n\nTextMask.defaultProps = {\n    value: null,\n    isControlled: true,\n    guide: true,\n    pipe: null,\n    placeholderChar: '_',\n    keepCharPositions: false,\n    showMask: false,\n    onChange: () => {},\n    componentRef: () => {},\n};\n","import React from 'react';\n\nconst isAndroid = typeof navigator !== 'undefined' && navigator !== null && /android/i.test(navigator.userAgent);\nconst isDocument = typeof document !== 'undefined' && document !== null;\n\nexport default class InputAdapter extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this._getRef = this._getRef.bind(this);\n        this._onChange = this._onChange.bind(this);\n    }\n\n    componentDidMount() {\n        this._setCaretPosition();\n    }\n\n    componentDidUpdate() {\n        this._setCaretPosition();\n    }\n\n    get caretPosition() {\n        return this.input.selectionEnd;\n    }\n\n    _getRef(ref) {\n        this.input = ref;\n    }\n\n    _onChange(event) {\n        event.persist();\n        this.props.onChange(event);\n    }\n\n    _setCaretPosition() {\n        if (isDocument && this.input === document.activeElement) {\n            if (isAndroid === true) {\n                setTimeout(() => {\n                    this.input.setSelectionRange(this.props.caretPosition, this.props.caretPosition, 'none');\n                }, 0);\n            } else {\n                this.input.setSelectionRange(this.props.caretPosition, this.props.caretPosition, 'none');\n            }\n        }\n    }\n\n    render() {\n        const {caretPosition, onChange, ...rest} = this.props;\n\n        return <input ref={this._getRef} type=\"text\" onChange={this._onChange} {...rest} />;\n    }\n}\n","import React from 'react';\n\nexport default class SpanAdapter extends React.PureComponent {\n    // eslint-disable-next-line class-methods-use-this\n    get caretPosition() {\n        return 0;\n    }\n\n    render() {\n        const {value, caretPosition, onChange, ...rest} = this.props;\n\n        return <span {...rest}>{value}</span>;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}