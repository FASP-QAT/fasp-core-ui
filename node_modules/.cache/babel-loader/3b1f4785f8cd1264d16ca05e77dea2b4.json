{"ast":null,"code":"'use strict';\n\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\nvar scheduleDrain;\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n\n    scheduleDrain = function scheduleDrain() {\n      element.data = called = ++called % 2;\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n\n    scheduleDrain = function scheduleDrain() {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function scheduleDrain() {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function scheduleDrain() {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\nvar draining;\nvar queue = []; //named nextTick for less confusing stack traces\n\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n\n    while (++i < len) {\n      oldQueue[i]();\n    }\n\n    len = queue.length;\n  }\n\n  draining = false;\n}\n\nmodule.exports = immediate;\n\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}","map":{"version":3,"sources":["/home/altius/NodeJs/gitHubRepos/fasp-core-ui/node_modules/immediate/lib/browser.js"],"names":["Mutation","global","MutationObserver","WebKitMutationObserver","scheduleDrain","called","observer","nextTick","element","document","createTextNode","observe","characterData","data","setImmediate","MessageChannel","channel","port1","onmessage","port2","postMessage","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","draining","queue","i","oldQueue","len","length","module","exports","immediate","task","push"],"mappings":"AAAA;;AACA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,gBAAP,IAA2BD,MAAM,CAACE,sBAAjD;AAEA,IAAIC,aAAJ;AAEA;AACE,MAAIJ,QAAJ,EAAc;AACZ,QAAIK,MAAM,GAAG,CAAb;AACA,QAAIC,QAAQ,GAAG,IAAIN,QAAJ,CAAaO,QAAb,CAAf;AACA,QAAIC,OAAO,GAAGP,MAAM,CAACQ,QAAP,CAAgBC,cAAhB,CAA+B,EAA/B,CAAd;AACAJ,IAAAA,QAAQ,CAACK,OAAT,CAAiBH,OAAjB,EAA0B;AACxBI,MAAAA,aAAa,EAAE;AADS,KAA1B;;AAGAR,IAAAA,aAAa,GAAG,yBAAY;AAC1BI,MAAAA,OAAO,CAACK,IAAR,GAAgBR,MAAM,GAAG,EAAEA,MAAF,GAAW,CAApC;AACD,KAFD;AAGD,GAVD,MAUO,IAAI,CAACJ,MAAM,CAACa,YAAR,IAAwB,OAAOb,MAAM,CAACc,cAAd,KAAiC,WAA7D,EAA0E;AAC/E,QAAIC,OAAO,GAAG,IAAIf,MAAM,CAACc,cAAX,EAAd;AACAC,IAAAA,OAAO,CAACC,KAAR,CAAcC,SAAd,GAA0BX,QAA1B;;AACAH,IAAAA,aAAa,GAAG,yBAAY;AAC1BY,MAAAA,OAAO,CAACG,KAAR,CAAcC,WAAd,CAA0B,CAA1B;AACD,KAFD;AAGD,GANM,MAMA,IAAI,cAAcnB,MAAd,IAAwB,wBAAwBA,MAAM,CAACQ,QAAP,CAAgBY,aAAhB,CAA8B,QAA9B,CAApD,EAA6F;AAClGjB,IAAAA,aAAa,GAAG,yBAAY;AAE1B;AACA;AACA,UAAIkB,QAAQ,GAAGrB,MAAM,CAACQ,QAAP,CAAgBY,aAAhB,CAA8B,QAA9B,CAAf;;AACAC,MAAAA,QAAQ,CAACC,kBAAT,GAA8B,YAAY;AACxChB,QAAAA,QAAQ;AAERe,QAAAA,QAAQ,CAACC,kBAAT,GAA8B,IAA9B;AACAD,QAAAA,QAAQ,CAACE,UAAT,CAAoBC,WAApB,CAAgCH,QAAhC;AACAA,QAAAA,QAAQ,GAAG,IAAX;AACD,OAND;;AAOArB,MAAAA,MAAM,CAACQ,QAAP,CAAgBiB,eAAhB,CAAgCC,WAAhC,CAA4CL,QAA5C;AACD,KAbD;AAcD,GAfM,MAeA;AACLlB,IAAAA,aAAa,GAAG,yBAAY;AAC1BwB,MAAAA,UAAU,CAACrB,QAAD,EAAW,CAAX,CAAV;AACD,KAFD;AAGD;AACF;AAED,IAAIsB,QAAJ;AACA,IAAIC,KAAK,GAAG,EAAZ,C,CACA;;AACA,SAASvB,QAAT,GAAoB;AAClBsB,EAAAA,QAAQ,GAAG,IAAX;AACA,MAAIE,CAAJ,EAAOC,QAAP;AACA,MAAIC,GAAG,GAAGH,KAAK,CAACI,MAAhB;;AACA,SAAOD,GAAP,EAAY;AACVD,IAAAA,QAAQ,GAAGF,KAAX;AACAA,IAAAA,KAAK,GAAG,EAAR;AACAC,IAAAA,CAAC,GAAG,CAAC,CAAL;;AACA,WAAO,EAAEA,CAAF,GAAME,GAAb,EAAkB;AAChBD,MAAAA,QAAQ,CAACD,CAAD,CAAR;AACD;;AACDE,IAAAA,GAAG,GAAGH,KAAK,CAACI,MAAZ;AACD;;AACDL,EAAAA,QAAQ,GAAG,KAAX;AACD;;AAEDM,MAAM,CAACC,OAAP,GAAiBC,SAAjB;;AACA,SAASA,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,MAAIR,KAAK,CAACS,IAAN,CAAWD,IAAX,MAAqB,CAArB,IAA0B,CAACT,QAA/B,EAAyC;AACvCzB,IAAAA,aAAa;AACd;AACF","sourcesContent":["'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}