{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _isSchema = _interopRequireDefault(require(\"./util/isSchema\"));\n\nvar Condition = /*#__PURE__*/function () {\n  function Condition(refs, options) {\n    this.refs = refs;\n\n    if (typeof options === 'function') {\n      this.fn = options;\n      return;\n    }\n\n    if (!(0, _has.default)(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    var is = options.is,\n        then = options.then,\n        otherwise = options.otherwise;\n    var check = typeof is === 'function' ? is : function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      return values.every(function (value) {\n        return value === is;\n      });\n    };\n\n    this.fn = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var options = args.pop();\n      var schema = args.pop();\n      var branch = check.apply(void 0, args) ? then : otherwise;\n      if (!branch) return undefined;\n      if (typeof branch === 'function') return branch(schema);\n      return schema.concat(branch.resolve(options));\n    };\n  }\n\n  var _proto = Condition.prototype;\n\n  _proto.resolve = function resolve(base, options) {\n    var values = this.refs.map(function (ref) {\n      return ref.getValue(options);\n    });\n    var schema = this.fn.apply(base, values.concat(base, options));\n    if (schema === undefined || schema === base) return base;\n    if (!(0, _isSchema.default)(schema)) throw new TypeError('conditions must return a schema object');\n    return schema.resolve(options);\n  };\n\n  return Condition;\n}();\n\nvar _default = Condition;\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/home/altius/Documents/QAT/fasp-core-ui/node_modules/yup/lib/Condition.js"],"names":["_interopRequireDefault","require","exports","__esModule","default","_has","_isSchema","Condition","refs","options","fn","TypeError","then","otherwise","is","check","_len","arguments","length","values","Array","_key","every","value","_len2","args","_key2","pop","schema","branch","apply","undefined","concat","resolve","_proto","prototype","base","map","ref","getValue","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _isSchema = _interopRequireDefault(require(\"./util/isSchema\"));\n\nvar Condition =\n/*#__PURE__*/\nfunction () {\n  function Condition(refs, options) {\n    this.refs = refs;\n\n    if (typeof options === 'function') {\n      this.fn = options;\n      return;\n    }\n\n    if (!(0, _has.default)(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    var is = options.is,\n        then = options.then,\n        otherwise = options.otherwise;\n    var check = typeof is === 'function' ? is : function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      return values.every(function (value) {\n        return value === is;\n      });\n    };\n\n    this.fn = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var options = args.pop();\n      var schema = args.pop();\n      var branch = check.apply(void 0, args) ? then : otherwise;\n      if (!branch) return undefined;\n      if (typeof branch === 'function') return branch(schema);\n      return schema.concat(branch.resolve(options));\n    };\n  }\n\n  var _proto = Condition.prototype;\n\n  _proto.resolve = function resolve(base, options) {\n    var values = this.refs.map(function (ref) {\n      return ref.getValue(options);\n    });\n    var schema = this.fn.apply(base, values.concat(base, options));\n    if (schema === undefined || schema === base) return base;\n    if (!(0, _isSchema.default)(schema)) throw new TypeError('conditions must return a schema object');\n    return schema.resolve(options);\n  };\n\n  return Condition;\n}();\n\nvar _default = Condition;\nexports.default = _default;\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}