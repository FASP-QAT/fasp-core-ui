{"ast":null,"code":"'use strict';\n\nvar utils = require('../utils');\n\nvar ConvertWorker = require('./ConvertWorker');\n\nvar GenericWorker = require('./GenericWorker');\n\nvar base64 = require('../base64');\n\nvar support = require(\"../support\");\n\nvar external = require(\"../external\");\n\nvar NodejsStreamOutputAdapter = null;\n\nif (support.nodestream) {\n  try {\n    NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');\n  } catch (e) {}\n}\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */\n\n\nfunction transformZipOutput(type, content, mimeType) {\n  switch (type) {\n    case \"blob\":\n      return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n\n    case \"base64\":\n      return base64.encode(content);\n\n    default:\n      return utils.transformTo(type, content);\n  }\n}\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */\n\n\nfunction concat(type, dataArray) {\n  var i,\n      index = 0,\n      res = null,\n      totalLength = 0;\n\n  for (i = 0; i < dataArray.length; i++) {\n    totalLength += dataArray[i].length;\n  }\n\n  switch (type) {\n    case \"string\":\n      return dataArray.join(\"\");\n\n    case \"array\":\n      return Array.prototype.concat.apply([], dataArray);\n\n    case \"uint8array\":\n      res = new Uint8Array(totalLength);\n\n      for (i = 0; i < dataArray.length; i++) {\n        res.set(dataArray[i], index);\n        index += dataArray[i].length;\n      }\n\n      return res;\n\n    case \"nodebuffer\":\n      return Buffer.concat(dataArray);\n\n    default:\n      throw new Error(\"concat : unsupported type '\" + type + \"'\");\n  }\n}\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */\n\n\nfunction _accumulate(helper, updateCallback) {\n  return new external.Promise(function (resolve, reject) {\n    var dataArray = [];\n    var chunkType = helper._internalType,\n        resultType = helper._outputType,\n        mimeType = helper._mimeType;\n    helper.on('data', function (data, meta) {\n      dataArray.push(data);\n\n      if (updateCallback) {\n        updateCallback(meta);\n      }\n    }).on('error', function (err) {\n      dataArray = [];\n      reject(err);\n    }).on('end', function () {\n      try {\n        var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n\n      dataArray = [];\n    }).resume();\n  });\n}\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */\n\n\nfunction StreamHelper(worker, outputType, mimeType) {\n  var internalType = outputType;\n\n  switch (outputType) {\n    case \"blob\":\n    case \"arraybuffer\":\n      internalType = \"uint8array\";\n      break;\n\n    case \"base64\":\n      internalType = \"string\";\n      break;\n  }\n\n  try {\n    // the type used internally\n    this._internalType = internalType; // the type used to output results\n\n    this._outputType = outputType; // the mime type\n\n    this._mimeType = mimeType;\n    utils.checkSupport(internalType);\n    this._worker = worker.pipe(new ConvertWorker(internalType)); // the last workers can be rewired without issues but we need to\n    // prevent any updates on previous workers.\n\n    worker.lock();\n  } catch (e) {\n    this._worker = new GenericWorker(\"error\");\n\n    this._worker.error(e);\n  }\n}\n\nStreamHelper.prototype = {\n  /**\n   * Listen a StreamHelper, accumulate its content and concatenate it into a\n   * complete block.\n   * @param {Function} updateCb the update callback.\n   * @return Promise the promise for the accumulation.\n   */\n  accumulate: function accumulate(updateCb) {\n    return _accumulate(this, updateCb);\n  },\n\n  /**\n   * Add a listener on an event triggered on a stream.\n   * @param {String} evt the name of the event\n   * @param {Function} fn the listener\n   * @return {StreamHelper} the current helper.\n   */\n  on: function on(evt, fn) {\n    var self = this;\n\n    if (evt === \"data\") {\n      this._worker.on(evt, function (chunk) {\n        fn.call(self, chunk.data, chunk.meta);\n      });\n    } else {\n      this._worker.on(evt, function () {\n        utils.delay(fn, arguments, self);\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * Resume the flow of chunks.\n   * @return {StreamHelper} the current helper.\n   */\n  resume: function resume() {\n    utils.delay(this._worker.resume, [], this._worker);\n    return this;\n  },\n\n  /**\n   * Pause the flow of chunks.\n   * @return {StreamHelper} the current helper.\n   */\n  pause: function pause() {\n    this._worker.pause();\n\n    return this;\n  },\n\n  /**\n   * Return a nodejs stream for this helper.\n   * @param {Function} updateCb the update callback.\n   * @return {NodejsStreamOutputAdapter} the nodejs stream.\n   */\n  toNodejsStream: function toNodejsStream(updateCb) {\n    utils.checkSupport(\"nodestream\");\n\n    if (this._outputType !== \"nodebuffer\") {\n      // an object stream containing blob/arraybuffer/uint8array/string\n      // is strange and I don't know if it would be useful.\n      // I you find this comment and have a good usecase, please open a\n      // bug report !\n      throw new Error(this._outputType + \" is not supported by this method\");\n    }\n\n    return new NodejsStreamOutputAdapter(this, {\n      objectMode: this._outputType !== \"nodebuffer\"\n    }, updateCb);\n  }\n};\nmodule.exports = StreamHelper;","map":{"version":3,"sources":["/home/altius/NodeJs/fasp-core-ui/node_modules/jszip/lib/stream/StreamHelper.js"],"names":["utils","require","ConvertWorker","GenericWorker","base64","support","external","NodejsStreamOutputAdapter","nodestream","e","transformZipOutput","type","content","mimeType","newBlob","transformTo","encode","concat","dataArray","i","index","res","totalLength","length","join","Array","prototype","apply","Uint8Array","set","Buffer","Error","accumulate","helper","updateCallback","Promise","resolve","reject","chunkType","_internalType","resultType","_outputType","_mimeType","on","data","meta","push","err","result","resume","StreamHelper","worker","outputType","internalType","checkSupport","_worker","pipe","lock","error","updateCb","evt","fn","self","chunk","call","delay","arguments","pause","toNodejsStream","objectMode","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = require('../utils');\nvar ConvertWorker = require('./ConvertWorker');\nvar GenericWorker = require('./GenericWorker');\nvar base64 = require('../base64');\nvar support = require(\"../support\");\nvar external = require(\"../external\");\n\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');\n    } catch(e) {}\n}\n\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */\nfunction transformZipOutput(type, content, mimeType) {\n    switch(type) {\n        case \"blob\" :\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\" :\n            return base64.encode(content);\n        default :\n            return utils.transformTo(type, content);\n    }\n}\n\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */\nfunction concat (type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++) {\n        totalLength += dataArray[i].length;\n    }\n    switch(type) {\n        case \"string\":\n            return dataArray.join(\"\");\n          case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\"  + type + \"'\");\n    }\n}\n\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */\nfunction accumulate(helper, updateCallback) {\n    return new external.Promise(function (resolve, reject){\n        var dataArray = [];\n        var chunkType = helper._internalType,\n            resultType = helper._outputType,\n            mimeType = helper._mimeType;\n        helper\n        .on('data', function (data, meta) {\n            dataArray.push(data);\n            if(updateCallback) {\n                updateCallback(meta);\n            }\n        })\n        .on('error', function(err) {\n            dataArray = [];\n            reject(err);\n        })\n        .on('end', function (){\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        })\n        .resume();\n    });\n}\n\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */\nfunction StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType) {\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n        break;\n        case \"base64\":\n            internalType = \"string\";\n        break;\n    }\n\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch(e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\n\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */\n    accumulate : function (updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */\n    on : function (evt, fn) {\n        var self = this;\n\n        if(evt === \"data\") {\n            this._worker.on(evt, function (chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function () {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    resume : function () {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    pause : function () {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */\n    toNodejsStream : function (updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode : this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\n\n\nmodule.exports = StreamHelper;\n"]},"metadata":{},"sourceType":"script"}