{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\n\nvar base64 = require('./base64');\n\nvar nodejsUtils = require('./nodejsUtils');\n\nvar setImmediate = require('set-immediate-shim');\n\nvar external = require(\"./external\");\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */\n\n\nfunction string2binary(str) {\n  var result = null;\n\n  if (support.uint8array) {\n    result = new Uint8Array(str.length);\n  } else {\n    result = new Array(str.length);\n  }\n\n  return stringToArrayLike(str, result);\n}\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */\n\n\nexports.newBlob = function (part, type) {\n  exports.checkSupport(\"blob\");\n\n  try {\n    // Blob constructor\n    return new Blob([part], {\n      type: type\n    });\n  } catch (e) {\n    try {\n      // deprecated, browser only, old way\n      var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n      var builder = new Builder();\n      builder.append(part);\n      return builder.getBlob(type);\n    } catch (e) {\n      // well, fuck ?!\n      throw new Error(\"Bug : can't construct the Blob.\");\n    }\n  }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\n\n\nfunction identity(input) {\n  return input;\n}\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\n\n\nfunction stringToArrayLike(str, array) {\n  for (var i = 0; i < str.length; ++i) {\n    array[i] = str.charCodeAt(i) & 0xFF;\n  }\n\n  return array;\n}\n/**\n * An helper for the function arrayLikeToString.\n * This contains static informations and functions that\n * can be optimized by the browser JIT compiler.\n */\n\n\nvar arrayToStringHelper = {\n  /**\n   * Transform an array of int into a string, chunk by chunk.\n   * See the performances notes on arrayLikeToString.\n   * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n   * @param {String} type the type of the array.\n   * @param {Integer} chunk the chunk size.\n   * @return {String} the resulting string.\n   * @throws Error if the chunk is too big for the stack.\n   */\n  stringifyByChunk: function stringifyByChunk(array, type, chunk) {\n    var result = [],\n        k = 0,\n        len = array.length; // shortcut\n\n    if (len <= chunk) {\n      return String.fromCharCode.apply(null, array);\n    }\n\n    while (k < len) {\n      if (type === \"array\" || type === \"nodebuffer\") {\n        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n      } else {\n        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n      }\n\n      k += chunk;\n    }\n\n    return result.join(\"\");\n  },\n\n  /**\n   * Call String.fromCharCode on every item in the array.\n   * This is the naive implementation, which generate A LOT of intermediate string.\n   * This should be used when everything else fail.\n   * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n   * @return {String} the result.\n   */\n  stringifyByChar: function stringifyByChar(array) {\n    var resultStr = \"\";\n\n    for (var i = 0; i < array.length; i++) {\n      resultStr += String.fromCharCode(array[i]);\n    }\n\n    return resultStr;\n  },\n  applyCanBeUsed: {\n    /**\n     * true if the browser accepts to use String.fromCharCode on Uint8Array\n     */\n    uint8array: function () {\n      try {\n        return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n      } catch (e) {\n        return false;\n      }\n    }(),\n\n    /**\n     * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n     */\n    nodebuffer: function () {\n      try {\n        return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n      } catch (e) {\n        return false;\n      }\n    }()\n  }\n};\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\n\nfunction arrayLikeToString(array) {\n  // Performances notes :\n  // --------------------\n  // String.fromCharCode.apply(null, array) is the fastest, see\n  // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n  // but the stack is limited (and we can get huge arrays !).\n  //\n  // result += String.fromCharCode(array[i]); generate too many strings !\n  //\n  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n  // TODO : we now have workers that split the work. Do we still need that ?\n  var chunk = 65536,\n      type = exports.getTypeOf(array),\n      canUseApply = true;\n\n  if (type === \"uint8array\") {\n    canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n  } else if (type === \"nodebuffer\") {\n    canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n  }\n\n  if (canUseApply) {\n    while (chunk > 1) {\n      try {\n        return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n      } catch (e) {\n        chunk = Math.floor(chunk / 2);\n      }\n    }\n  } // no apply or chunk error : slow and painful algorithm\n  // default browser on android 4.*\n\n\n  return arrayToStringHelper.stringifyByChar(array);\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\n\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n  for (var i = 0; i < arrayFrom.length; i++) {\n    arrayTo[i] = arrayFrom[i];\n  }\n\n  return arrayTo;\n} // a matrix containing functions to transform everything into everything.\n\n\nvar transform = {}; // string to ?\n\ntransform[\"string\"] = {\n  \"string\": identity,\n  \"array\": function array(input) {\n    return stringToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function arraybuffer(input) {\n    return transform[\"string\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function uint8array(input) {\n    return stringToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": function nodebuffer(input) {\n    return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n  }\n}; // array to ?\n\ntransform[\"array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": identity,\n  \"arraybuffer\": function arraybuffer(input) {\n    return new Uint8Array(input).buffer;\n  },\n  \"uint8array\": function uint8array(input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function nodebuffer(input) {\n    return nodejsUtils.newBufferFrom(input);\n  }\n}; // arraybuffer to ?\n\ntransform[\"arraybuffer\"] = {\n  \"string\": function string(input) {\n    return arrayLikeToString(new Uint8Array(input));\n  },\n  \"array\": function array(input) {\n    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n  },\n  \"arraybuffer\": identity,\n  \"uint8array\": function uint8array(input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function nodebuffer(input) {\n    return nodejsUtils.newBufferFrom(new Uint8Array(input));\n  }\n}; // uint8array to ?\n\ntransform[\"uint8array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function array(input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function arraybuffer(input) {\n    return input.buffer;\n  },\n  \"uint8array\": identity,\n  \"nodebuffer\": function nodebuffer(input) {\n    return nodejsUtils.newBufferFrom(input);\n  }\n}; // nodebuffer to ?\n\ntransform[\"nodebuffer\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function array(input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function arraybuffer(input) {\n    return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function uint8array(input) {\n    return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": identity\n};\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\n\nexports.transformTo = function (outputType, input) {\n  if (!input) {\n    // undefined, null, etc\n    // an empty string won't harm.\n    input = \"\";\n  }\n\n  if (!outputType) {\n    return input;\n  }\n\n  exports.checkSupport(outputType);\n  var inputType = exports.getTypeOf(input);\n  var result = transform[inputType][outputType](input);\n  return result;\n};\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\n\n\nexports.getTypeOf = function (input) {\n  if (typeof input === \"string\") {\n    return \"string\";\n  }\n\n  if (Object.prototype.toString.call(input) === \"[object Array]\") {\n    return \"array\";\n  }\n\n  if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n    return \"nodebuffer\";\n  }\n\n  if (support.uint8array && input instanceof Uint8Array) {\n    return \"uint8array\";\n  }\n\n  if (support.arraybuffer && input instanceof ArrayBuffer) {\n    return \"arraybuffer\";\n  }\n};\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\n\n\nexports.checkSupport = function (type) {\n  var supported = support[type.toLowerCase()];\n\n  if (!supported) {\n    throw new Error(type + \" is not supported by this platform\");\n  }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\n\nexports.pretty = function (str) {\n  var res = '',\n      code,\n      i;\n\n  for (i = 0; i < (str || \"\").length; i++) {\n    code = str.charCodeAt(i);\n    res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  }\n\n  return res;\n};\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */\n\n\nexports.delay = function (callback, args, self) {\n  setImmediate(function () {\n    callback.apply(self || null, args || []);\n  });\n};\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */\n\n\nexports.inherits = function (ctor, superCtor) {\n  var Obj = function Obj() {};\n\n  Obj.prototype = superCtor.prototype;\n  ctor.prototype = new Obj();\n};\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\n\n\nexports.extend = function () {\n  var result = {},\n      i,\n      attr;\n\n  for (i = 0; i < arguments.length; i++) {\n    // arguments is not enumerable in some browsers\n    for (attr in arguments[i]) {\n      if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n        result[attr] = arguments[i][attr];\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */\n\n\nexports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n  // if inputData is already a promise, this flatten it.\n  var promise = external.Promise.resolve(inputData).then(function (data) {\n    var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n\n    if (isBlob && typeof FileReader !== \"undefined\") {\n      return new external.Promise(function (resolve, reject) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n          resolve(e.target.result);\n        };\n\n        reader.onerror = function (e) {\n          reject(e.target.error);\n        };\n\n        reader.readAsArrayBuffer(data);\n      });\n    } else {\n      return data;\n    }\n  });\n  return promise.then(function (data) {\n    var dataType = exports.getTypeOf(data);\n\n    if (!dataType) {\n      return external.Promise.reject(new Error(\"Can't read the data of '\" + name + \"'. Is it \" + \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"));\n    } // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n\n\n    if (dataType === \"arraybuffer\") {\n      data = exports.transformTo(\"uint8array\", data);\n    } else if (dataType === \"string\") {\n      if (isBase64) {\n        data = base64.decode(data);\n      } else if (isBinary) {\n        // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n        if (isOptimizedBinaryString !== true) {\n          // this is a string, not in a base64 format.\n          // Be sure that this is a correct \"binary string\"\n          data = string2binary(data);\n        }\n      }\n    }\n\n    return data;\n  });\n};","map":{"version":3,"sources":["/home/altius/NodeJs/gitHubRepos/fasp-core-ui/node_modules/jszip/lib/utils.js"],"names":["support","require","base64","nodejsUtils","setImmediate","external","string2binary","str","result","uint8array","Uint8Array","length","Array","stringToArrayLike","exports","newBlob","part","type","checkSupport","Blob","e","Builder","self","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","builder","append","getBlob","Error","identity","input","array","i","charCodeAt","arrayToStringHelper","stringifyByChunk","chunk","k","len","String","fromCharCode","apply","push","slice","Math","min","subarray","join","stringifyByChar","resultStr","applyCanBeUsed","nodebuffer","allocBuffer","arrayLikeToString","getTypeOf","canUseApply","floor","applyFromCharCode","arrayLikeToArrayLike","arrayFrom","arrayTo","transform","buffer","newBufferFrom","byteLength","transformTo","outputType","inputType","Object","prototype","toString","call","isBuffer","arraybuffer","ArrayBuffer","supported","toLowerCase","MAX_VALUE_16BITS","MAX_VALUE_32BITS","pretty","res","code","toUpperCase","delay","callback","args","inherits","ctor","superCtor","Obj","extend","attr","arguments","hasOwnProperty","prepareContent","name","inputData","isBinary","isOptimizedBinaryString","isBase64","promise","Promise","resolve","then","data","isBlob","blob","indexOf","FileReader","reject","reader","onload","target","onerror","error","readAsArrayBuffer","dataType","decode"],"mappings":"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","sourcesContent":["'use strict';\n\nvar support = require('./support');\nvar base64 = require('./base64');\nvar nodejsUtils = require('./nodejsUtils');\nvar setImmediate = require('set-immediate-shim');\nvar external = require(\"./external\");\n\n\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */\nfunction string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n      result = new Uint8Array(str.length);\n    } else {\n      result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */\nexports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n\n    try {\n        // Blob constructor\n        return new Blob([part], {\n            type: type\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * An helper for the function arrayLikeToString.\n * This contains static informations and functions that\n * can be optimized by the browser JIT compiler.\n */\nvar arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */\n    stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while (k < len) {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */\n    stringifyByChar: function(array){\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++) {\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed : {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */\n        uint8array : (function () {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */\n        nodebuffer : (function () {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })()\n    }\n};\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536,\n        type = exports.getTypeOf(array),\n        canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n\n    if (canUseApply) {\n        while (chunk > 1) {\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */\nexports.delay = function(callback, args, self) {\n    setImmediate(function () {\n        callback.apply(self || null, args || []);\n    });\n};\n\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */\nexports.inherits = function (ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */\nexports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        \n        \n        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function (resolve, reject) {\n                var reader = new FileReader();\n\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n\n        if (!dataType) {\n            return external.Promise.reject(\n                new Error(\"Can't read the data of '\" + name + \"'. Is it \" +\n                          \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\")\n            );\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            }\n            else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n"]},"metadata":{},"sourceType":"script"}