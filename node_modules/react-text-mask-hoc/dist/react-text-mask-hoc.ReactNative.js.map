{"version":3,"file":"react-text-mask-hoc.ReactNative.js","sources":["../node_modules/text-mask-core/src/adjustCaretPosition.js","../node_modules/text-mask-core/src/constants.js","../node_modules/text-mask-core/src/utilities.js","../node_modules/text-mask-core/src/conformToMask.js","../src/TextMaskTransformer.js","../src/TextMask.js","../src/TextInputAdapter.js","../src/TextAdapter.js"],"sourcesContent":["const defaultArray = []\nconst emptyString = ''\n\nexport default function adjustCaretPosition({\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = defaultArray,\n  caretTrapIndexes = defaultArray\n}) {\n  if (currentCaretPosition === 0 || !rawValue.length) { return 0 }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const conformedValueLength = conformedValue.length\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) { return currentCaretPosition }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar = isAddition && (\n    previousConformedValue === conformedValue ||\n    conformedValue === placeholder\n  )\n\n  let startingSearchIndex = 0\n  let trackRightCharacter\n  let targetChar\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase()\n    const normalizedRawValue = rawValue.toLowerCase()\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString)\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter((char) => normalizedConformedValue.indexOf(char) !== -1)\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1]\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft = (\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]\n    )\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true\n      targetChar = rawValue[currentCaretPosition]\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map((index) => normalizedConformedValue[index])\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter((char) => char === targetChar).length\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter((char) => char === targetChar).length\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split(emptyString)\n      .filter((char, index) => (\n        // Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar &&\n\n        // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      ))\n      .length\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches = (\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0)\n    )\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i]\n\n      startingSearchIndex = i + 1\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    }\n  }\n}\n","export const placeholderChar = '_'\nexport const strFunction = 'function'\n","import {placeholderChar as defaultPlaceholderChar} from './constants'\n\nconst emptyArray = []\n\nexport function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = defaultPlaceholderChar) {\n  if (!isArray(mask)) {\n    throw new Error(\n      'Text-mask:convertMaskToPlaceholder; The mask property must be an array.'\n    )\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n      'that is not present in your mask as your placeholder character.\\n\\n' +\n      `The placeholder character that was received is: ${JSON.stringify(placeholderChar)}\\n\\n` +\n      `The mask that was received is: ${JSON.stringify(mask)}`\n    )\n  }\n\n  return mask.map((char) => {\n    return (char instanceof RegExp) ? placeholderChar : char\n  }).join('')\n}\n\nexport function isArray(value) {\n  return (Array.isArray && Array.isArray(value)) || value instanceof Array\n}\n\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number' && value.length === undefined && !isNaN(value)\n}\n\nexport function isNil(value) {\n  return typeof value === 'undefined' || value === null\n}\n\nconst strCaretTrap = '[]'\nexport function processCaretTraps(mask) {\n  const indexes = []\n\n  let indexOfCaretTrap\n  while(indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) { // eslint-disable-line\n    indexes.push(indexOfCaretTrap)\n\n    mask.splice(indexOfCaretTrap, 1)\n  }\n\n  return {maskWithoutCaretTraps: mask, indexes}\n}\n","import {convertMaskToPlaceholder, isArray, processCaretTraps} from './utilities'\nimport {placeholderChar as defaultPlaceholderChar, strFunction} from './constants'\n\nconst emptyArray = []\nconst emptyString = ''\n\nexport default function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === strFunction) {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config)\n\n      // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n      mask = processCaretTraps(mask).maskWithoutCaretTraps\n    } else {\n      throw new Error(\n        'Text-mask:conformToMask; The mask property must be an array.'\n      )\n    }\n  }\n\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = emptyString,\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions\n  } = config\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const maskLength = mask.length\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0)\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance)\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = emptyString\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue = (\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength)\n    )\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue\n    .split(emptyString)\n    .map((char, i) => ({char, isNew: i >= indexOfFirstChange && i < indexOfLastChange}))\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const {char} = rawValueArr[i]\n\n    if (char !== placeholderChar) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength\n\n      if (char === placeholder[(shouldOffset) ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1)\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString\n  let someCharsRejected = false\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i]\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const {char: rawValueChar, isNew} = rawValueArr.shift()\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop\n\n          // Else if, the character we got from the user input is not a placeholder, let's see\n          // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              isNew === false ||\n              previousConformedValue === emptyString ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += rawValueChar\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length\n              let indexOfNextAvailablePlaceholderChar = null\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let i = 0; i < rawValueArrLength; i++) {\n                const charData = rawValueArr[i]\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = i\n                  break\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1)\n\n              // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n              // discard it.\n              } else {\n                i--\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop\n          } else {\n            someCharsRejected = true\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength)\n      }\n\n      // And we break\n      break\n\n    // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n    // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1)\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString\n    }\n  }\n\n  return {conformedValue, meta: {someCharsRejected}}\n}\n","import adjustCaretPosition from 'text-mask-core/src/adjustCaretPosition';\nimport conformToMask from 'text-mask-core/src/conformToMask';\nimport {convertMaskToPlaceholder, isString, isNumber, processCaretTraps} from 'text-mask-core/src/utilities';\nimport {placeholderChar as defaultPlaceholderChar} from 'text-mask-core/src/constants';\n\nfunction getSafeRawValue(inputValue) {\n    if (inputValue == null) return '';\n    if (isString(inputValue)) return inputValue;\n    if (isNumber(inputValue)) return String(inputValue);\n\n    throw new Error(\n        \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\n            `received was:\\n\\n ${JSON.stringify(inputValue)}`\n    );\n}\n\nexport default class TextMaskTransformer {\n    constructor() {\n        this.previousConformedValue = undefined;\n        this.previousPlaceholder = undefined;\n    }\n\n    update({\n        value: rawValue,\n        caretPosition: currentCaretPosition,\n        mask: providedMask,\n        guide,\n        pipe,\n        placeholderChar = defaultPlaceholderChar,\n        keepCharPositions = false,\n        showMask = false,\n    }) {\n        // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n        // This check is here to handle controlled framework components that repeat the `update` call on every render.\n        if (rawValue === this.previousConformedValue) {\n            return null;\n        }\n\n        // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together.\n        // If such a `mask` is passed, we destructure it below, so the rest of the code can work normally\n        // as if a separate `mask` and a `pipe` were passed.\n        if (\n            providedMask != null &&\n            typeof providedMask === 'object' &&\n            providedMask.pipe != null &&\n            providedMask.mask != null\n        ) {\n            /* eslint-disable no-param-reassign, prefer-destructuring */\n            pipe = providedMask.pipe;\n            providedMask = providedMask.mask;\n            /* eslint-enable */\n        }\n\n        // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`,\n        // the placeholder would be `(___)` if the `placeholderChar` is set to `_`.\n        let placeholder;\n\n        // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function,\n        // we will have to call that function to get the mask array.\n        let mask;\n\n        // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n        // correct `placeholder`.\n        if (Array.isArray(providedMask)) {\n            placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n        }\n\n        // We check the provided `rawValue` before moving further.\n        // If it's something we can't work with `getSafeRawValue` will throw.\n        const safeRawValue = getSafeRawValue(rawValue);\n\n        // In framework components that support reactivity, it's possible to turn off masking by passing\n        // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n        if (providedMask === false) {\n            return {\n                value: safeRawValue,\n                caretPosition: currentCaretPosition,\n            };\n        }\n\n        let caretTrapIndexes;\n\n        // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n        // Then we also need to get the `placeholder`\n        if (typeof providedMask === 'function') {\n            mask = providedMask(safeRawValue, {\n                currentCaretPosition,\n                previousConformedValue: this.previousConformedValue,\n                placeholderChar,\n            });\n\n            // disable masking if `mask` is `false`\n            if (mask === false) {\n                return null;\n            }\n\n            // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n            // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n            // the indexes of the caret traps.\n            const {maskWithoutCaretTraps, indexes} = processCaretTraps(mask);\n\n            // The processed mask is what we're interested in\n            mask = maskWithoutCaretTraps;\n            // And we need to store these indexes because they're needed by `adjustCaretPosition`\n            caretTrapIndexes = indexes;\n\n            placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n            // If the `providedMask` is not a function, we just use it as-is.\n        } else {\n            mask = providedMask;\n        }\n\n        // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n        const conformToMaskConfig = {\n            previousConformedValue: this.previousConformedValue,\n            guide,\n            placeholderChar,\n            pipe,\n            placeholder,\n            currentCaretPosition,\n            keepCharPositions,\n        };\n\n        // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n        const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n\n        // The following few lines are to support the `pipe` feature.\n        const piped = typeof pipe === 'function';\n\n        let pipeResults = {};\n\n        // If `pipe` is a function, we call it.\n        if (piped) {\n            // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n            pipeResults = pipe(\n                conformedValue,\n                {rawValue: safeRawValue, ...conformToMaskConfig}\n            );\n\n            // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just\n            // return `false` to indicate rejection. Or return just a string when there are no piped characters.\n            // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n            // of the code can work with.\n            if (pipeResults === false) {\n                // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,\n                // and set `rejected` to `true`.\n                pipeResults = {value: this.previousConformedValue, rejected: true};\n            } else if (isString(pipeResults)) {\n                pipeResults = {value: pipeResults};\n            }\n        }\n\n        // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n        // returned by `conformToMask`.\n        const finalConformedValue = piped ? pipeResults.value : conformedValue;\n\n        // After determining the conformed value, we will need to know where to set\n        // the caret position. `adjustCaretPosition` will tell us.\n        const adjustedCaretPosition = adjustCaretPosition({\n            previousConformedValue: this.previousConformedValue,\n            previousPlaceholder: this.previousPlaceholder,\n            conformedValue: finalConformedValue,\n            placeholder,\n            rawValue: safeRawValue,\n            currentCaretPosition,\n            placeholderChar,\n            indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n            caretTrapIndexes,\n        });\n\n        // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n        const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n        const emptyValue = showMask ? placeholder : '';\n        const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n\n        this.previousConformedValue = inputElementValue; // store value for access for next time\n        this.previousPlaceholder = placeholder;\n\n        return {\n            value: inputElementValue,\n            caretPosition: adjustedCaretPosition,\n        };\n    }\n}\n","import React from 'react';\nimport {propsEqual} from 'react-shallow-equal';\nimport TextMaskTransformer from './TextMaskTransformer';\n\nexport default class TextMask extends React.PureComponent {\n    constructor(props, context) {\n        super(props, context);\n        this._update = this._update.bind(this);\n        this._getRef = this._getRef.bind(this);\n        this._onChange = this._onChange.bind(this);\n\n        this.component = null;\n        this.textMaskTransformer = new TextMaskTransformer();\n\n        const value = props.value != null ? props.value : '';\n        const nextUpdate = this._update({...props, value});\n\n        if (nextUpdate !== null) {\n            this.state = {\n                value: nextUpdate.value,\n                caretPosition: nextUpdate.caretPosition,\n            };\n        } else {\n            this.state = {\n                value: '',\n                caretPosition: 0,\n            };\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        const ignore = [];\n\n        if (nextProps.isControlled === false) {\n            ignore.push('value');\n        }\n\n        if (!propsEqual(this.props, nextProps, {ignore})) {\n            const value =\n                nextProps.isControlled === true && nextProps.value != null ? nextProps.value : this.state.value;\n            const nextUpdate = this._update({...nextProps, value});\n            if (nextUpdate !== null) {\n                this.setState(nextUpdate);\n            }\n        }\n    }\n\n    get value() {\n        return this.state.value;\n    }\n\n    _update(props) {\n        return this.textMaskTransformer.update({\n            value: props.value,\n            caretPosition: this.component != null ? this.component.caretPosition : 0,\n            mask: props.mask,\n            guide: props.guide,\n            pipe: props.pipe,\n            placeholderChar: props.placeholderChar,\n            keepCharPositions: props.keepCharPositions,\n            showMask: props.showMask,\n        });\n    }\n\n    _getRef(comp) {\n        if (comp) {\n            this.props.componentRef(comp);\n            this.component = comp;\n        }\n    }\n\n    _onChange(event) {\n        if (event) {\n            const rawValue = typeof event.target === 'object' ? event.target.value : event.text;\n            const nextUpdate = this._update({...this.props, value: rawValue});\n\n            if (nextUpdate !== null) {\n                this.setState(nextUpdate, () => {\n                    this.props.onChange(event, nextUpdate);\n                });\n            } else {\n                this.props.onChange(event, this.state);\n                this.forceUpdate();\n            }\n        }\n    }\n\n    focus() {\n        if (this.component.input) this.component.input.focus();\n    }\n\n    blur() {\n        if (this.component.input) this.component.input.blur();\n    }\n\n    render() {\n        const {\n            Component,\n            value,\n            isControlled,\n            mask,\n            guide,\n            pipe,\n            placeholderChar,\n            keepCharPositions,\n            showMask,\n            componentRef,\n            onChange,\n            ...rest\n        } = this.props;\n\n        return (\n            <Component\n                {...rest}\n                value={this.state.value}\n                caretPosition={this.state.caretPosition}\n                onChange={this._onChange}\n                ref={this._getRef}\n            />\n        );\n    }\n}\n\nTextMask.defaultProps = {\n    value: null,\n    isControlled: true,\n    guide: true,\n    pipe: null,\n    placeholderChar: '_',\n    keepCharPositions: false,\n    showMask: false,\n    onChange: () => {},\n    componentRef: () => {},\n};\n","import React from 'react';\nimport {TextInput} from 'react-native'; // eslint-disable-line\nimport {propsEqual} from 'react-shallow-equal';\n\nexport default class TextInputAdapter extends React.Component {\n    constructor(props) {\n        super(props);\n        this._lastOnChangeEvent = undefined;\n        this._selection = undefined;\n        this._onSelectionChange = this._onSelectionChange.bind(this);\n        this._onChange = this._onChange.bind(this);\n        this._getRef = this._getRef.bind(this);\n    }\n\n    componentDidMount() {\n        this._setNativeProps(this.props.value, this.props.caretPosition);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        this._setNativeProps(nextProps.value, nextProps.caretPosition);\n    }\n\n    shouldComponentUpdate(nextProps) {\n        return !propsEqual(this.props, nextProps, {\n            ignore: ['value', 'caretPosition'],\n        });\n    }\n\n    get caretPosition() {\n        return this._selection || 0;\n    }\n\n    // onChange() runs before onSelectionChange(), so when text-mask gets selection\n    // it's a previous value instead of the current one.\n    _onSelectionChange(event) {\n        this._selection = event.nativeEvent.selection.end;\n\n        if (this._lastOnChangeEvent) {\n            this.props.onChange(this._lastOnChangeEvent);\n            this._lastOnChangeEvent = undefined;\n        }\n    }\n\n    _onChange({nativeEvent}) {\n        this._lastOnChangeEvent = nativeEvent;\n    }\n\n    _getRef(ref) {\n        this.input = ref;\n    }\n\n    _setNativeProps(value, caretPosition) {\n        this.input.setNativeProps({text: value});\n        this.input.setNativeProps({selection: {start: caretPosition, end: caretPosition}});\n    }\n\n    render() {\n        const {value, caretPosition, onChange, ...rest} = this.props;\n\n        return (\n            <TextInput\n                {...rest}\n                ref={this._getRef}\n                onChange={this._onChange}\n                onSelectionChange={this._onSelectionChange}\n            />\n        );\n    }\n}\n","import React from 'react';\nimport {Text} from 'react-native'; // eslint-disable-line\n\nexport default class TextAdapter extends React.PureComponent {\n    // eslint-disable-next-line class-methods-use-this\n    get caretPosition() {\n        return 0;\n    }\n\n    render() {\n        const {value, caretPosition, onChange, ...rest} = this.props;\n\n        return <Text {...rest}>{value}</Text>;\n    }\n}\n"],"names":["defaultArray","emptyString","adjustCaretPosition","previousConformedValue","previousPlaceholder","currentCaretPosition","conformedValue","rawValue","placeholderChar","placeholder","indexesOfPipedChars","caretTrapIndexes","length","rawValueLength","previousConformedValueLength","placeholderLength","conformedValueLength","editLength","isAddition","isFirstRawValue","isPartialMultiCharEdit","possiblyHasRejectedChar","startingSearchIndex","trackRightCharacter","targetChar","normalizedConformedValue","toLowerCase","normalizedRawValue","leftHalfChars","substr","split","intersection","filter","char","indexOf","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","undefined","pipedChars","map","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","i","conformedValueChar","lastPlaceholderChar","strFunction","emptyArray","convertMaskToPlaceholder","mask","defaultPlaceholderChar","isArray","Error","JSON","stringify","RegExp","join","value","Array","isString","String","isNumber","isNaN","strCaretTrap","processCaretTraps","indexes","indexOfCaretTrap","push","splice","maskWithoutCaretTraps","conformToMask","config","guide","keepCharPositions","suppressGuide","maskLength","editDistance","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","slice","rawValueArr","isNew","shouldOffset","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","indexOfLastFilledPlaceholderChar","meta","getSafeRawValue","inputValue","TextMaskTransformer","constructor","update","caretPosition","providedMask","pipe","showMask","safeRawValue","conformToMaskConfig","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","TextMask","React","PureComponent","props","context","_update","bind","_getRef","_onChange","component","textMaskTransformer","nextUpdate","state","componentWillReceiveProps","nextProps","ignore","isControlled","propsEqual","setState","comp","componentRef","event","target","text","onChange","forceUpdate","focus","input","blur","render","Component","rest","defaultProps","TextInputAdapter","_lastOnChangeEvent","_selection","_onSelectionChange","componentDidMount","_setNativeProps","shouldComponentUpdate","nativeEvent","selection","end","ref","setNativeProps","start","TextAdapter"],"mappings":"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"}